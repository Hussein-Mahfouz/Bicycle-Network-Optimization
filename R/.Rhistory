rownames(x4$'MSOA11CD$`Area of residence`')
x4
# tranform into distance matrix for routing
x2 <- x %>% pivot_wider(names_from = `Area of workplace`, values_from = potential_demand)
rownames(x2) <- (x2$'MSOA11CD$`Area of residence`')
rownames(x2) <- (x2$MSOA11CD$`Area of residence`)
rownames(x2) <- (x2$`Area of residence`)
# tranform into distance matrix for routing
x2 <- x %>% pivot_wider(names_from = `Area of workplace`, values_from = potential_demand)
column_to_rownames(.x2, var = "Area of residence")
column_to_rownames(x2, var = "Area of residence")
x4 <- column_to_rownames(x2, var = "Area of residence")
View(x4)
# tranform into distance matrix for routing
x5 <- x %>% pivot_wider(names_from = `Area of workplace`, values_from = potential_demand) %>%
column_to_rownames(var = "Area of residence")
View(x5)
# tranform into distance matrix for routing.
# column_to_rownames added so that 1st column is not the MSOA names. It assigns the MSOA names to the row ID
x2 <- x %>% pivot_wider(names_from = `Area of workplace`, values_from = potential_demand) %>%
tibble::column_to_rownames(var = "Area of residence")
rm(x3)
rm(x4)
rm(x5)
# get coordinates of origins and destinations. I am doi
x3 <- x %>% left_join(lon_lat, by = c("Area of residence" = "MSOA11CD")) %>%
rename(from_lon = lon, from_lat = lat)  %>%
left_join(lon_lat, by = c("Area of workplace" = "MSOA11CD")) %>%
rename(to_lon = lon, to_lat = lat)
View(x3)
from <- x3 %>% subset(select = c(from_lon, from_lat))
to   <- x3 %>% subset(select = c(to_lon, to_lat))
rm(iow_gf_region)
rm(london_gf_region)
View(from)
View(to)
View(x2)
graph <- read_csv('../data/weighted_graph.csv')
View(graph)
View(x2)
res <- dodgr_flows_aggregate(
graph = graph,
from = from,
to = to,
flows = x2,
contract = TRUE,
quiet = FALSE)
View(to)
View(x3)
View(x2)
View(x)
# I have it stored locally, but perhaps it is better to generate it from the distance_matrix script,
# due to differences in classes
graph2 <- read_csv('../data/weighted_graph.csv')
library(tidyverse)
library(sf)
library(dodgr)
# I have it stored locally, but perhaps it is better to generate it from the distance_matrix script,
# due to differences in classes
graph2 <- read_csv('../data/weighted_graph.csv')
x <- dodgr_to_sf(graph2)
View(x)
plot(st_geometry(x))
library(tidyverse)
library(sf)
library(dodgr)
streetnet2 <- dodgr_streetnet("london uk", expand = 0.05)
object.size(streetnet2)
rm(streetnet2)
clear_dodgr_cache()
ls()
# 217101 rows    # 1794.96 mb
memory.size(max=F)
gc()
memory.size()
pryr::mem_used()
pryr::mem_used()
bb_buffer <- function(city, buffer){
x <- osmdata::getbb (city, format_out = "sf_polygon") %>%
sf::st_transform(crs = 27700) %>%  # change crs to one that uses metres
sf::st_buffer(dist = buffer) %>%     # add buffer in metres
sf::st_transform(crs = 4326) %>%   # get original crs
sf::st_coordinates()               # get coordinates since dodgr_streetnet takes matrix argument
return(x)
}
bb_ldn <- bb_buffer(city = "london uk", buffer = 1000)
pryr::mem_used()
streetnet <- dodgr_streetnet(bbox = bb_ldn)    # rows     # mb
library(tidyverse)
library(dodgr)
library(sf)
library(osmdata)
library(lwgeom)
# this is a lookup table matching MSOAs to major towns and cities
city_names <- read_csv('../data-raw/Middle_Layer_Super_Output_Area__2011__to_Major_Towns_and_Cities__December_2015__Lookup_in_England_and_Wales.csv')
# change column name
city_names <- city_names %>% rename(city = TCITY15NM)
# flow data from the 2011 census https://www.nomisweb.co.uk/census/2011/bulk/rOD1
flows <- read_csv('../data-raw/flow_data.csv')
# add a column with the city name corresponding to each Residence MSOA
flows <- flows %>% left_join(city_names[,c("MSOA11CD", "city")],
by = c("Area of residence" = "MSOA11CD")) %>%
rename(city_origin = city) # rename column so that we know it is referring to the 'Area of residence'
# add a column with the city name corresponding to each Workplace MSOA
flows <- flows %>% left_join(city_names[,c("MSOA11CD", "city")],
by = c("Area of workplace" = "MSOA11CD")) %>%
rename(city_dest = city) # rename column so that we know it is referring to the 'Area of workplace'
View(flows)
# Subset flows to keep only those that are within a specific city
flows_internal <- function(name) {
x <- flows %>% filter(city_origin == name, city_dest == name)
return(x)
}
# use function to get flows between all MSOAs in Oxford
flows_ox <- flows_internal("Oxford") %>% select(1:3) %>%
rename(potential_demand = `All categories: Method of travel to work`)
View(flows_ox)
# download spatial data locally and read it
msoa_boundaries <- st_read('../data-raw/MSOA_2011_Boundaries/Middle_Layer_Super_Output_Areas__December_2011__Boundaries.shp') %>%
st_transform(4326)   # transform to EPSG 4326 for dodgr routing later
st_crs(msoa_boundaries)
# function to filter MSOAs that are within a certain city
msoas_city <- function(name) {
x <- city_names %>% filter(city == name)
return(x)
}
# get msoas in Oxford
msoas_ox <- msoas_city("Oxford")
View(msoas_ox)
# Add spatial data to oxford msoas
spatial_ox <-
msoas_ox[, c("MSOA11CD", "MSOA11NM")] %>%
left_join(msoa_boundaries[ , c("msoa11cd", "geometry")], by = c("MSOA11CD" = "msoa11cd")) %>%
st_as_sf() %>% lwgeom::st_make_valid() %>%
mutate(centroid = st_centroid(geometry))  # we will need centroids to calculate distance matrix
View(spatial_ox)
rm(msoa_boundaries)
# Remove border geometry and set centroids as geometry. This does not overwrite 'spatial_ox' sf
msoa_centroids <-
st_drop_geometry(spatial_ox) %>%
st_set_geometry('centroid')
View(spatial_ox)
View(msoa_centroids)
View(spatial_ox)
pryr::mem_used()
plot(msoa_centroids)
plot(st_geometry(msoa_centroids))
plot(st_geometry(msoa_centroids)) + plot(st_geometry(spatial_ox))
plot(st_geometry(spatial_ox))
plot(st_geometry(spatial_ox, msoa_centroids))
plot(st_geometry(spatial_ox))
plot(st_geometry(spatial_ox), add = TRUe)
plot(st_geometry(spatial_ox), add = TRUE)
plot(st_geometry(spatial_ox))
plot(st_geometry(msoa_centroids), add = TRUE)
#######################
# snapping centroids to specific OSM points
x<- dodgr_streetnet("oxford uk", expand = 0.05)
plot(st_geometry(x), add = TRUE)
View(spatial_ox)
st_boundary(spatial_ox)
st_boundary(spatial_ox$geometry)
plot(st_geometry((st_boundary(spatial_ox$geometry))
plot(st_geometry((st_boundary(spatial_ox$geometry))))
plot(st_geometry((st_polygonize(spatial_ox))))
plot(st_geometry((st_polygonize(spatial_ox$geometry))))
plot(st_geometry((st_convex_hull(spatial_ox))))
plot(st_geometry((st_combine(spatial_ox))))
comb <- st_geometry((st_combine(spatial_ox)))
View(comb)
class(comb)
st_crs(ccom)
st_crs(comb)
bound <- st_boundary(comb)
plot(st_geometry(bound))
View(bound)
t1 <- st_buffer(spatial_ox, dist = 0)
plot(st_geometry(t1))
t2 <- st_buffer(comb, dist = 0)
plot(st_geometry(t1))
plot(st_geometry(t2))
class(t2)
View(t2)
t2 >%> as.matrix()
t2 %>% as.matrix()
t3 %>% t2 <- as.matrix()
t3 <- t2 %>% as.matrix()
View(t3)
View(x)
class(x)
plot(st_geometry(x))
st_crs(x)
rm(t1, t2, t3)
rm(comb, bound)
unique(x$description)
unique(x$highway)
class(x)
class(x$geometry)
x%geometry[1]
x%geometry[[1]]
x%geometry
x$geometry[1]
g <- x$geometry[1]
View(g)
pt = st_cast(g, "POINT")
View(pt)
x2 <- x %>% filter(highway = primary)
x2 <- x %>% filter(highway == primary)
unique(x$highway)
x2 <- x %>% filter(highway == 'primary')
plot(st_geometry(x2))
x2 <- x %>% filter(highway %in% c('primary', 'secondary', 'tertiary'))
plot(st_geometry(x2))
plot(st_geometry(x))
plot(st_geometry(x2))
x2 <- x %>% filter(highway %in% c('primary', 'secondary', 'tertiary'))
plot(st_geometry(x2))
x2 <- x %>% filter(highway %in% c('primary', 'secondary', 'tertiary', 'residential'))
plot(st_geometry(x2))
x2 <- x %>% filter(highway %in% c('primary', 'secondary', 'tertiary', 'service'))
plot(st_geometry(x2))
x2 <- x %>% filter(highway %in% c('primary', 'secondary', 'tertiary', 'cycleway'))
plot(st_geometry(x2))
x2 <- x %>% filter(highway %in% c('primary', 'secondary', 'tertiary', 'track'))
plot(st_geometry(x2))
class(msoa_centroids)
#######################
# snapping centroids to specific OSM points
x<- dodgr_streetnet("oxford uk", expand = 0.05) %>%
filter(highway %in% c('primary', 'secondary', 'tertiary'))
rm(x2, pt, g)
st_snap_points = function(x, y, max_dist = 1000) {
if (inherits(x, "sf")) n = nrow(x)
if (inherits(x, "sfc")) n = length(x)
out = do.call(c,
lapply(seq(n), function(i) {
nrst = st_nearest_points(st_geometry(x)[i], y)
nrst_len = st_length(nrst)
nrst_mn = which.min(nrst_len)
if (as.vector(nrst_len[nrst_mn]) > max_dist) return(st_geometry(x)[i])
return(st_cast(nrst[nrst_mn], "POINT")[2])
})
)
return(out)
}
res <- st_snap_points(msoa_centroids, x)
View(x)
View(res)
res2 <- res %>% as.matrix()
View(res2)
class(res)
plot(st_geometry(res))
plot(st_geometry(x))
plot(st_geometry(msoa_centroids))
plot(st_geometry(x), add = TRUE)
plot(st_geometry(res), add = TRUE, col = 'red')
res <- st_snap_points(msoa_centroids, x, max_dist = 5000)
plot(st_geometry(msoa_centroids))
plot(st_geometry(x), add = TRUE)
plot(st_geometry(res), add = TRUE, col = 'red')
res <- st_snap_points(msoa_centroids, x, max_dist = 100)
plot(st_geometry(msoa_centroids))
plot(st_geometry(x), add = TRUE)
plot(st_geometry(res), add = TRUE, col = 'red')
res <- st_snap_points(msoa_centroids, x, max_dist = 500)
plot(st_geometry(msoa_centroids))
plot(st_geometry(x), add = TRUE)
plot(st_geometry(res), add = TRUE, col = 'red')
plot(st_geometry(msoa_centroids))
plot(st_geometry(x), add = TRUE)
plot(st_geometry(res), add = TRUE, col = 'red')
########################
# function to split c(lat, lon) to two seperate columns  FROM JM London (https://github.com/r-spatial/sf/issues/231)
# lat = Y lon = X
split_lon_lat <- function(x, names = c("lon","lat")) {
stopifnot(inherits(x,"sf") && inherits(sf::st_geometry(x),"sfc_POINT"))
ret <- sf::st_coordinates(x)
ret <- tibble::as_tibble(ret)
stopifnot(length(names) == ncol(ret))
x <- x[ , !names(x) %in% names]
ret <- setNames(ret,names)
dplyr::bind_cols(x,ret)
}
testttt <- res %>% split_lon_lat()
View(res)
st_as_sf(res)
poin <- st_as_sf(res)
View(poin)
testttt <- poin %>% split_lon_lat()
View(testttt)
# get lon and lat as seperate columns
lon_lat <-  msoa_centroids %>% split_lon_lat() %>% select(-c(MSOA11NM))
View(lon_lat)
View(msoa_centroids)
res2[[1]]
?bind_cols
res <- st_snap_points(msoa_centroids, x, max_dist = 500) %>% st_as_sf()
View(res)
res <- st_snap_points(msoa_centroids, x, max_dist = 500) %>% st_as_sf() %>% bind_cols(msoa_centroids)
View(res)
msoa_centroids
msoa_centroids$MSOA11CD
res <- st_snap_points(msoa_centroids, x, max_dist = 500) %>% st_as_sf() %>% bind_cols(msoa_centroids$MSOA11CD)
View(res)
View(res)
res <- st_snap_points(msoa_centroids, x, max_dist = 500) %>%
st_as_sf() %>%
bind_cols(msoa_centroids) %>%
select (-c(MSOA11NM, centroid))
View(res)
rm(x, testttt, res2, res, poin)
# function from https://stackoverflow.com/questions/51292952/snap-a-point-to-the-closest-point-on-a-line-segment-using-sf
st_snap_points = function(x, y, max_dist = 1000) {
if (inherits(x, "sf")) n = nrow(x)
if (inherits(x, "sfc")) n = length(x)
out = do.call(c,
lapply(seq(n), function(i) {
nrst = st_nearest_points(st_geometry(x)[i], y)
nrst_len = st_length(nrst)
nrst_mn = which.min(nrst_len)
if (as.vector(nrst_len[nrst_mn]) > max_dist) return(st_geometry(x)[i])
return(st_cast(nrst[nrst_mn], "POINT")[2])
})
)
return(out)
}
msoa_centoids_snapped <-
st_snap_points(msoa_centroids, roads, max_dist = 500) %>%   # if dist to nearest road > max dist, point is unchanged
st_as_sf() %>%   # convert to get it in a dataframe
bind_cols(msoa_centroids) %>%  # bind with msoa centroids df to ge MSOA IDs
select (-c(MSOA11NM, centroid))  # drop old geometry
#1. Get stree network and filter main road types (filter argument can be changed)
roads <- dodgr_streetnet("oxford uk", expand = 0.05) %>%
filter(highway %in% c('primary', 'secondary', 'tertiary'))
msoa_centoids_snapped <-
st_snap_points(msoa_centroids, roads, max_dist = 500) %>%   # if dist to nearest road > max dist, point is unchanged
st_as_sf() %>%   # convert to get it in a dataframe
bind_cols(msoa_centroids) %>%  # bind with msoa centroids df to ge MSOA IDs
select (-c(MSOA11NM, centroid))  # drop old geometry
View(msoa_centroids)
View(msoa_centroids)
# check how the points were shifted
plot(st_geometry(msoa_centroids))
plot(st_geometry(roads), add = TRUE)
plot(st_geometry(msoa_centoids_snapped), add = TRUE, col = 'red')
# check how the points were shifted
plot(st_geometry(roads))
plot(st_geometry(msoa_centroids), add = TRUE, col = 'red')
plot(st_geometry(msoa_centoids_snapped), add = TRUE, col = 'green')
msoa_centroids[1]
msoa_centroids[[1]]
msoa_centroids$centroid[1]
plot(st_geometrymsoa_centroids$centroid[1])
plot(st_geometry(msoa_centroids$centroid[1]))
View(msoa_centoids_snapped)
msoa_centoids_snapped <-
st_snap_points(msoa_centroids, roads, max_dist = 500) %>%   # if dist to nearest road > max dist, point is unchanged
st_as_sf() %>%   # convert to get it in a dataframe
bind_cols(msoa_centroids) %>%  # bind with msoa centroids df to ge MSOA IDs
select(-c(MSOA11NM, centroid)) %>% # drop old geometry
rename(centroid = x)
View(msoa_centoids_snapped)
plot(st_geometry(msoa_centroids$centroid[1]))
plot(st_geometry(roads))
plot(st_geometry(msoa_centroids$centroid[1]), add = TRUE, col = 'red')
plot(st_geometry(msoa_centroids_snapped$centroid[1]), add = TRUE, col = 'green')
rm(msoa_centoids_snapped)
msoa_centroids_snapped <-
st_snap_points(msoa_centroids, roads, max_dist = 500) %>%   # if dist to nearest road > max dist, point is unchanged
st_as_sf() %>%   # convert to get it in a dataframe
bind_cols(msoa_centroids) %>%  # bind with msoa centroids df to ge MSOA IDs
select(-c(MSOA11NM, centroid)) %>% # drop old geometry
rename(centroid = x)
# check how the points were shifted
plot(st_geometry(roads))
plot(st_geometry(msoa_centroids), add = TRUE, col = 'red')
plot(st_geometry(msoa_centroids_snapped), add = TRUE, col = 'green')
plot(st_geometry(roads))
plot(st_geometry(msoa_centroids$centroid[1]), add = TRUE, col = 'red')
plot(st_geometry(msoa_centroids_snapped$centroid[1]), add = TRUE, col = 'green')
plot(st_geometry(roads))
plot(st_geometry(msoa_centroids$centroid[5]), add = TRUE, col = 'red')
plot(st_geometry(msoa_centroids_snapped$centroid[5]), add = TRUE, col = 'green')
View(msoa_centroids_snapped)
# get lon and lat as seperate columns
lon_lat <-  msoa_centroids %>% split_lon_lat() %>% select(-c(MSOA11NM))
View(lon_lat)
View(msoa_centroids_snapped)
View(msoa_centroids)
msoa_centroids_snapped <-
st_snap_points(msoa_centroids, roads, max_dist = 500) %>%   # if dist to nearest road > max dist, point is unchanged
st_as_sf() %>%   # convert to get it in a dataframe
bind_cols(msoa_centroids) %>%  # bind with msoa centroids df to ge MSOA IDs
select(-c(centroid)) %>% # drop old geometry
rename(centroid = x)
lon_lat2 <-  msoa_centroids_snapped %>% split_lon_lat() %>% select(-c(MSOA11NM))
View(lon_lat2)
View(lon_lat)
rm(lon_lat2)
#clear environment
rm(roads)
#1. Get stree network and filter main road types (filter argument can be changed)
roads <- dodgr_streetnet("oxford uk", expand = 0.05) %>%
filter(highway %in% c('primary', 'secondary', 'tertiary'))
# function from https://stackoverflow.com/questions/51292952/snap-a-point-to-the-closest-point-on-a-line-segment-using-sf
st_snap_points = function(x, y, max_dist = 1000) {
if (inherits(x, "sf")) n = nrow(x)
if (inherits(x, "sfc")) n = length(x)
out = do.call(c,
lapply(seq(n), function(i) {
nrst = st_nearest_points(st_geometry(x)[i], y)
nrst_len = st_length(nrst)
nrst_mn = which.min(nrst_len)
if (as.vector(nrst_len[nrst_mn]) > max_dist) return(st_geometry(x)[i])
return(st_cast(nrst[nrst_mn], "POINT")[2])
})
)
return(out)
}
msoa_centroids_snapped <-
st_snap_points(msoa_centroids, roads, max_dist = 500) %>%   # if dist to nearest road > max dist, point is unchanged
st_as_sf() %>%   # convert to get it in a dataframe
bind_cols(msoa_centroids) %>%  # bind with msoa centroids df to ge MSOA IDs
select(-c(centroid)) %>% # drop old geometry
rename(centroid = x)
# check how the points were shifted
plot(st_geometry(roads))
plot(st_geometry(msoa_centroids), add = TRUE, col = 'red')
plot(st_geometry(msoa_centroids_snapped), add = TRUE, col = 'green')
# check that bind_cols() was correct. Plot individual points:
plot(st_geometry(roads))
# check that bind_cols() was correct. Plot individual points:
plot(st_geometry(roads))
plot(st_geometry(msoa_centroids$centroid[1]), add = TRUE, col = 'red')
plot(st_geometry(msoa_centroids_snapped$centroid[1]), add = TRUE, col = 'green')
plot(st_geometry(msoa_centroids$centroid[2]), add = TRUE, col = 'red')
plot(st_geometry(msoa_centroids_snapped$centroid[2]), add = TRUE, col = 'green')
plot(st_geometry(msoa_centroids$centroid[3]), add = TRUE, col = 'red')
plot(st_geometry(msoa_centroids_snapped$centroid[3]), add = TRUE, col = 'green')
plot(st_geometry(msoa_centroids$centroid[4]), add = TRUE, col = 'red')
plot(st_geometry(msoa_centroids_snapped$centroid[4]), add = TRUE, col = 'green')
#clear environment
rm(roads)
#1. Get stree network and filter main road types (filter argument can be changed)
roads <- dodgr_streetnet("oxford uk", expand = 0.05) %>%
filter(highway %in% c('primary', 'secondary', 'tertiary'))
msoa_centroids_snapped <-
st_snap_points(msoa_centroids, roads, max_dist = 1000) %>%   # if dist to nearest road > max dist, point is unchanged
st_as_sf() %>%   # convert to get it in a dataframe
bind_cols(msoa_centroids) %>%  # bind with msoa centroids df to ge MSOA IDs
select(-c(centroid)) %>% # drop old geometry
rename(centroid = x)
# check that bind_cols() was correct. Plot individual points:
plot(st_geometry(roads))
plot(st_geometry(msoa_centroids$centroid[1]), add = TRUE, col = 'red')
plot(st_geometry(msoa_centroids_snapped$centroid[1]), add = TRUE, col = 'green')
plot(st_geometry(msoa_centroids$centroid[2]), add = TRUE, col = 'red')
plot(st_geometry(msoa_centroids_snapped$centroid[2]), add = TRUE, col = 'green')
plot(st_geometry(msoa_centroids$centroid[3]), add = TRUE, col = 'red')
plot(st_geometry(msoa_centroids_snapped$centroid[3]), add = TRUE, col = 'green')
plot(st_geometry(msoa_centroids$centroid[4]), add = TRUE, col = 'red')
plot(st_geometry(msoa_centroids_snapped$centroid[4]), add = TRUE, col = 'green')
#clear environment
rm(roads)
#1. Get stree network and filter main road types (filter argument can be changed)
roads <- dodgr_streetnet("oxford uk", expand = 0.05) %>%
filter(highway %in% c('primary', 'secondary', 'tertiary'))
msoa_centroids_snapped <-
st_snap_points(msoa_centroids, roads, max_dist = 1000) %>%   # if dist to nearest road > max dist, point is unchanged
st_as_sf() %>%   # convert to get it in a dataframe
bind_cols(msoa_centroids) %>%  # bind with msoa centroids df to ge MSOA IDs
select(-c(centroid)) %>% # drop old geometry
rename(centroid = x)
# check that bind_cols() was correct. Plot individual points:
plot(st_geometry(roads))
plot(st_geometry(msoa_centroids$centroid[1]), add = TRUE, col = 'red')
plot(st_geometry(msoa_centroids_snapped$centroid[1]), add = TRUE, col = 'green')
plot(st_geometry(msoa_centroids$centroid[2]), add = TRUE, col = 'red')
plot(st_geometry(msoa_centroids_snapped$centroid[2]), add = TRUE, col = 'green')
plot(st_geometry(msoa_centroids$centroid[3]), add = TRUE, col = 'red')
plot(st_geometry(msoa_centroids_snapped$centroid[3]), add = TRUE, col = 'green')
plot(st_geometry(msoa_centroids$centroid[4]), add = TRUE, col = 'red')
plot(st_geometry(msoa_centroids_snapped$centroid[4]), add = TRUE, col = 'green')
plot(st_geometry(msoa_centroids$centroid[5]), add = TRUE, col = 'red')
plot(st_geometry(msoa_centroids_snapped$centroid[5]), add = TRUE, col = 'green')
plot(st_geometry(msoa_centroids$centroid[6]), add = TRUE, col = 'red')
plot(st_geometry(msoa_centroids_snapped$centroid[6]), add = TRUE, col = 'green')
plot(st_geometry(msoa_centroids$centroid[7]), add = TRUE, col = 'red')
plot(st_geometry(msoa_centroids_snapped$centroid[7]), add = TRUE, col = 'green')
# check that bind_cols() was correct. Plot individual points:
plot(st_geometry(roads))
for (i in 1:10){
plot(st_geometry(msoa_centroids$centroid[i]), add = TRUE, col = 'red')
plot(st_geometry(msoa_centroids_snapped$centroid[i]), add = TRUE, col = 'green')
}
# check that bind_cols() was correct. Plot individual points:
plot(st_geometry(roads))
for (i in 1:15){
plot(st_geometry(msoa_centroids$centroid[i]), add = TRUE, col = 'red')
plot(st_geometry(msoa_centroids_snapped$centroid[i]), add = TRUE, col = 'green')
}
# check that bind_cols() was correct. Plot individual points:
plot(st_geometry(roads))
for (i in 1:15){
plot(st_geometry(msoa_centroids$centroid[i]), add = TRUE, col = 'red')
plot(st_geometry(msoa_centroids_snapped$centroid[i]), add = TRUE, col = 'blue')
}
View(roads)
# check that bind_cols() was correct. Plot individual points:
plot(st_geometry(roads), col = highway)
# check that bind_cols() was correct. Plot individual points:
plot(st_geometry(roads), col = roads$highway)
