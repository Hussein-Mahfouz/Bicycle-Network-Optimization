j = j + ((graph$d[graph$edge_id == edge_sel]) -  (graph$d[graph$edge_id == edge_sel] * graph$cycle_infra[graph$edge_id == edge_sel]))
} else{
# if neighb is empty, add the community number to the check_conn vector
check_conn[k] <- k
# if check_conn vector becomes populated with all communities, break out of function
if (!is.na(sum(check_conn))){
message(paste0("There are no more connected edges to add for all communities. The returned object has ", round(j/1000),
"km out of the specified ", km, "km"))
graph <- graph %>% filter(!(is.na(sequen))) %>%
arrange(sequen) # arrange in the order they were added
return(graph)
}
}
} else{
graph <- graph
j <- j
}
}
i <- i+1
}
graph <- graph %>% filter(!(is.na(sequen))) %>%
arrange(sequen) # arrange in the order they were added
return(graph)
}
# test <- growth_community_2(graph_sf, 500, "flow")
#
# test %>% st_drop_geometry %>% group_by(cycle_infra) %>% summarize(length = sum(d))
#
# plot(st_geometry(graph_sf), col = 'lightgrey')
# plot(test["Community"], add = TRUE)
# plot(test["Community"])
################################################ FUNCTION 5 ################################################
###########################################################################################################
### THIS FUNCTION IS ALMOST IDENTICAL TO FUNCTION 4, WITH ONE EXCEPTION. IN FUNCTION 4, IF THERE ARE NO ###
### REMAINING NEIGHBORS IN A COMMUNITY, WE STOP ADDING EDGES FROM THAT COMMUNITY. IN SOME CASES, THE  ###
### EDGES IN A COMMUNITY FORM MORE THAN 1 CONNECTED COMPONENT, SO THERE MAY STILL BE EDGES, EVEN THOUGH ###
### NONE OF THEM ARE CONNECTED TO THE CURRENT SOLUTION. IF THIS IS THE CASE, WE FIND THE BEST (EG. HIGHEST ###
### FLOW) REMAINING UNCONNECTED EDGE IN THE COMMUNITY AND ADD IT TO THE SOLUTION.
###########################################################################################################
# 1. select investment length (km)
# 2. Identify edge with highest flow in each community
# 3. Add these edges to solution
# 4. For edges in each community
#      - identify edges that neighbor the edges in the solution from that community
#      - Select edge with highest flow and append it to the solution
# 5. Keep looping over the communities and selecting edges until you reach the investment length
# 6. If there are no neighboring edges remaining for a community, check all remaing edges in the community
#    and add the best one, regardless of connectivity
###############################################################
growth_community_3 <- function(graph, km, col_name) {
### check if km chosen is a reasonable number (using a predefined function)
check_km_value(graph, km)
# add sequence column
graph$sequen <- NA
# Group by community and get the edge with the highest flow in each group
# to pass column name in function (specific to dplyr): https://stackoverflow.com/questions/48062213/dplyr-using-column-names-as-function-arguments
# we get max flow per group, and then get max distance on result in case of ties (so that we end up with 1 row per group)
x <- graph %>% group_by(Community) %>%
slice_max(order_by = !! sym(col_name)) %>%
slice_max(order_by = d)
# assign sequence 0 to all edges that are in x
graph$sequen[graph$edge_id %in% x$edge_id] <- 0
####################
# split the graph into a list of dataframes with length = number of communities
split <- graph %>%
group_split(Community)
####################
# we keep track of the edges in the solution, so that we can identify the edges that neighbor them
chosen <- graph %>% filter(!(is.na(sequen)))
# i keeps track of which iteration a chosen edge was added in
i <- 1
# j counts km added. We don't count segments that already have cycling infrastructure
j <- sum(chosen$d) - sum(chosen$cycle_infra * chosen$d)
#while length of chosen segments is less than the specified length
while (j/1000 < km){
# for each community
for (k in 1:length(split)){
# edges in community k that have already been chosen
chosen    <- split[[k]] %>% filter(!(is.na(sequen)))
# edges in community k that have not been chosen yet
remaining <- split[[k]] %>% filter(is.na(sequen))
if (nrow(remaining) > 0){
# all edges that neighbor the edges in the community that have already been chosen
neighb_id <- split[[k]]$edge_id[which(split[[k]]$from_id %in% chosen$from_id |
split[[k]]$from_id %in% chosen$to_id |
split[[k]]$to_id %in% chosen$from_id |
split[[k]]$to_id %in% chosen$to_id)]
# filter out the remaining edges to keep only the ones that neighbor the chosen edges
#### PROBLEM COULD BE HERE
neighb <- remaining %>% filter(edge_id %in% neighb_id)
# it may be the case that the remaining edges in the community are not connected to the chosen edges
# the edges in each community do not necessarily form one component. If this is the case, then neighb will
# return an empty sf feature, so an if function is added to only continue if neighb is not empty
if (nrow(neighb) > 0){
#get the edge_id of the edge with the highest flow out of the neighb df
edge_sel <- neighb$edge_id[which.max(neighb[[col_name]])]
# assign a sequence to the selected edge. Assign it to the graph sf and to the split sf
graph$sequen[graph$edge_id == edge_sel] <- i
# we need it here as well because this is where we filter nas for the 'chosen' variable
split[[k]]$sequen[split[[k]]$edge_id == edge_sel] <- i
# Only count length of selected edges that have no cycling infrastructure. (edge length - (edge_length*cycling_infra binary value))
j = j + ((graph$d[graph$edge_id == edge_sel]) -  (graph$d[graph$edge_id == edge_sel] * graph$cycle_infra[graph$edge_id == edge_sel]))
} else{
#get the edge_id of the edge with the highest flow out of the neighb df
edge_sel <- remaining$edge_id[which.max(remaining[[col_name]])]
graph$sequen[graph$edge_id == edge_sel] <- i
# we need it here as well because this is where we filter nas for the 'chosen' variable
split[[k]]$sequen[split[[k]]$edge_id == edge_sel] <- i
# Only count length of selected edges that have no cycling infrastructure. (edge length - (edge_length*cycling_infra binary value))
j = j + ((graph$d[graph$edge_id == edge_sel]) -  (graph$d[graph$edge_id == edge_sel] * graph$cycle_infra[graph$edge_id == edge_sel]))
}
} else{
graph <- graph
j <- j
}
}
i <- i+1
}
graph <- graph %>% filter(!(is.na(sequen))) %>%
arrange(sequen) # arrange in the order they were added
return(graph)
}
# test <- growth_community_3(graph_sf, 50, "flow")
#
# test %>% st_drop_geometry %>% group_by(cycle_infra) %>% summarize(length = sum(d))
#
# plot(st_geometry(graph_sf), col = 'lightgrey')
# plot(test["Community"], add = TRUE)
# plot(test["Community"])
################################################ FUNCTION 6 ################################################
###########################################################################################################
### THIS FUNCTION IS ALMOST IDENTICAL TO FUNCTION 5 WITH ONE EXCEPTION. WE START WITH ALL EDGES THAT ALREADY ##
### HAVE CYCLING INFRASTRUCTURE. THESE ARE THE BEGINNING OF THE SOLUTION. TO ENSURE THAT THERE IS AT LEAST ##
### ONE EDGE FROM EACH COMMUNITY, WE GET THE EDGE WITH THE HIGHEST FLOW IN EACH COMMUNITY AND APPEND IT TO ##
### THE SOLUTION AT SEQUENCE 0.
###########################################################################################################
# 1. select investment length (km)
# 2. Identify edge with highest flow in each community
# 3. Identify all edges that have designated cycle infrastructure
# 4. Get union of 2 & 3. This ensures that we start with at least one edge from each community
# 4. For edges in each community
#      a. identify edges that neighbour the edges in the solution from that community
#      b. Select edge with highest flow from [a] and append it to the solution
# 5. Keep looping over the communities and selecting edges until you reach the investment length
# 6. If there are no neighboring edges remaining for a community, check all remaing edges in the community
#    and add the best one, regardless of connectivity
# At each iteration we calculate the no of components that make up the current solution. We start with all cycling
# infrastructure and then as edges are added, the number of components should go down
growth_community_4 <- function(graph, km, col_name) {
### check if km chosen is a reasonable number. Function is defined in the beginning
check_km_value(graph, km)
# add empty columns for sequence, number of compenents in solution, and size of largest connected component
graph <- graph %>% mutate(sequen= NA,
no_components = NA,
gcc_size = NA)
# Group by community and get the edge with the highest flow in each group
# to pass column name in function (specific to dplyr): https://stackoverflow.com/questions/48062213/dplyr-using-column-names-as-function-arguments
# we get max flow per group, and then get max distance on result in case of ties (so that we end up with 1 row per group)
x <- graph %>% group_by(Community) %>%
slice_max(order_by = !! sym(col_name)) %>%
slice_max(order_by = d) %>% ungroup()
# get all edges with cycling infrastructure
y <- graph %>% dplyr::filter(cycle_infra == 1)
x <- rbind(x, y)
# remove duplicates
x <- dplyr::distinct(x, edge_id, .keep_all = TRUE)
# assign sequence 0 to all edges that are in x
graph$sequen[graph$edge_id %in% x$edge_id] <- 0
# we need a network representation to get no. of components and size of gcc using igraph
net <- graph  %>% filter(!(is.na(sequen))) %>% as_sfnetwork()
# calculate no of components and size of largest connected component (for current solution)
# only add the values to the rows in the graph that are also in x
graph$no_components[graph$edge_id %in% x$edge_id] <- igraph::count_components(net)
graph$gcc_size[graph$edge_id %in% x$edge_id] <- components(net)$csize[which.max(components(net)$csize)]
# split the graph into a list of dataframes with length = number of communities
split <- graph %>%
group_split(Community)
# i keeps track of which iteration a chosen edge was added in
i <- 1
# j counts km added. We don't count segments that already have cycling infrastructure
j <- sum(x$d) - sum(x$cycle_infra * x$d)
#while length of chosen segments is less than the specified length
while (j/1000 < km){
# for each community
for (k in 1:length(split)){
# edges in community k that have already been chosen
chosen    <- split[[k]] %>% filter(!(is.na(sequen)))
# edges in community k that have not been chosen yet
remaining <- split[[k]] %>% filter(is.na(sequen))
# we need a network representation to get no. of components and size of gcc using igraph
net <- graph  %>% filter(!(is.na(sequen))) %>% as_sfnetwork()
# if there are still edges in the community to be selected
if (nrow(remaining) > 0){
# all edges that neighbor the edges in the community that have already been chosen
neighb_id <- split[[k]]$edge_id[which(split[[k]]$from_id %in% chosen$from_id |
split[[k]]$from_id %in% chosen$to_id |
split[[k]]$to_id %in% chosen$from_id |
split[[k]]$to_id %in% chosen$to_id)]
# filter out the remaining edges to keep only the ones that neighbor the chosen edges
neighb <- remaining %>% filter(edge_id %in% neighb_id)
# it may be the case that the remaining edges in the community are not connected to the chosen edges
# the edges in each community do not necessarily form one component. If this is the case, then neighb will
# return an empty sf feature, so an if function is added to only continue if neighb is not empty
if (nrow(neighb) > 0){
#get the edge_id of the edge with the highest flow out of the neighb df
edge_sel <- neighb$edge_id[which.max(neighb[[col_name]])]
# assign a sequence to the selected edge
graph$sequen[graph$edge_id == edge_sel] <- i
# we need it here as well because this is where we filter nas for the 'chosen' variable
split[[k]]$sequen[split[[k]]$edge_id == edge_sel] <- i
# get no of components and size of largest connected component at this iteration
graph$no_components[graph$edge_id == edge_sel] <- igraph::count_components(net)
graph$gcc_size[graph$edge_id == edge_sel] <- components(net)$csize[which.max(components(net)$csize)]
# Only count length of selected edges that have no cycling infrastructure. (edge length - (edge_length*cycling_infra binary value))
j = j + ((graph$d[graph$edge_id == edge_sel]) - (graph$d[graph$edge_id == edge_sel] * graph$cycle_infra[graph$edge_id == edge_sel]))
} else{
#get the edge_id of the edge with the highest flow out of the remaining df
edge_sel <- remaining$edge_id[which.max(remaining[[col_name]])]
# assign a sequence to the selected edge
graph$sequen[graph$edge_id == edge_sel] <- i
# we need it here as well because this is where we filter nas for the 'chosen' variable
split[[k]]$sequen[split[[k]]$edge_id == edge_sel] <- i
# get no of components and size of largest connected component at this iteration
graph$no_components[graph$edge_id == edge_sel] <- igraph::count_components(net)
graph$gcc_size[graph$edge_id == edge_sel] <- components(net)$csize[which.max(components(net)$csize)]
# Only count length of selected edges that have no cycling infrastructure. (edge length - (edge_length*cycling_infra binary value))
j = j + ((graph$d[graph$edge_id == edge_sel]) - (graph$d[graph$edge_id == edge_sel] * graph$cycle_infra[graph$edge_id == edge_sel]))
}
} else{
# if there are no more edges in that community, do nothing
graph <- graph
j <- j
}
}
i <- i+1
}
graph <- graph %>% filter(!(is.na(sequen))) %>%
arrange(sequen) # arrange in the order they were added
return(graph)
}
#debugging - START
# graph_sf %>% st_drop_geometry %>% group_by(Community, cycle_infra) %>% summarize(length = sum(d)/ 1000)
# graph_sf %>% st_drop_geometry %>% summarize(length = sum(d)/ 1000)
# graph_sf %>% st_drop_geometry %>% group_by(cycle_infra) %>% summarize(length = sum(d)/ 1000)
# graph_sf %>% st_drop_geometry %>% filter(cycle_infra ==0) %>% group_by(Community) %>% summarize(length = sum(d)/ 1000)
# graph_sf %>% st_drop_geometry %>% filter(cycle_infra ==0) %>%  summarize(length = sum(d)/ 1000)
# f <-graph_sf %>% st_drop_geometry %>% filter(cycle_infra ==1)
#
#
# test <- growth_community_4(graph_sf, 400, "flow")
#
# graph_sf %>% st_drop_geometry %>% filter(cycle_infra ==0) %>% group_by(Community) %>% summarize(length = sum(d)/ 1000)
# test %>% ungroup %>% st_drop_geometry %>% filter(cycle_infra ==0) %>% group_by(Community) %>% summarize(length = sum(d)/ 1000)
#
#
#
# test %>% st_drop_geometry %>% group_by(cycle_infra) %>% summarize(length = sum(d))
#
# plot(st_geometry(graph_sf), col = 'lightgrey')
# plot(test["Community"], add = TRUE)
# plot(test["Community"])
# plot(test["sequen"])
## adding igraph connected components function takes double the time
#system.time({ growth_community_4(graph_sf, 30, "flow") })
library(sf)
library(tidyverse)
library(ggtext)
library(tmap)
#create a directory to store data related to this city (does nothing if directory already exists)
dir.create(paste0("../data/", chosen_city, "/Plots/Growth_Results"), showWarnings = FALSE)
graph_sf <- readRDS(paste0("../data/", chosen_city, "/graph_with_flows_weighted_communities.RDS"))
View(graph_sf)
library(sf)
library(tidyverse)
library(ggtext)
library(tmap)
#create a directory to store data related to this city (does nothing if directory already exists)
dir.create(paste0("../data/", chosen_city, "/Plots/Growth_Results"), showWarnings = FALSE)
graph_sf <- readRDS(paste0("../data/", chosen_city, "/graph_with_flows_weighted_communities.RDS"))
# we weigh the flow on each edge by its distance. We can then get how much of the commuter km are satisfied
graph_sf$person_km <- graph_sf$flow * graph_sf$d
########## GGPLOTS SHOWING FLOW/PERSON_KM SATISFIED AT THE NETWORK LEVEL AND AT THE COMMUNITY LEVEL #############
# get percentage contibution of each edge to the network (distance, flow, person_km)
graph_sf <- graph_sf %>%
mutate(perc_dist = (d/sum(d))  *100,      # edge length as % of total network length
perc_flow = (flow/sum(flow))  *100, # flow on edge as % of total
perc_person_km = (person_km/sum(person_km))  *100) %>% # % of person_km satisfied
# get the same % for each community as a % of the community totals
group_by(Community) %>%
mutate(perc_dist_comm = (d/sum(d)) * 100,
perc_flow_comm = (flow/sum(flow))  *100,
perc_person_km_comm = (person_km/sum(person_km))  *100) %>%
ungroup()
########################################### FUNCTION 1: GROWTH FROM ONE SEED/EDGE ###########################################
# let's grow the network based on the flow column
grow_flow_1_seed <- growth_one_seed(graph = graph_sf, km = 500, col_name = "flow")
# prepare a dataframe for plotting the results
grow_flow_1_seed_c <- grow_flow_1_seed %>%
arrange(sequen) %>%  # make sure it is arranged by sequen (Otherwise cumulative sum values will be wrong)
ungroup %>%   # not sure why it is a grouped df. This only has an effect on the select argument
#st_drop_geometry() %>%
dplyr::select(Community, d, flow, cycle_infra, sequen, perc_dist, perc_flow,
perc_person_km, perc_dist_comm, perc_flow_comm, perc_person_km_comm, highway)
# cumsum is cumulative sum. We see how much of person_km has been satisfied after each iteration
grow_flow_1_seed_c <- grow_flow_1_seed_c %>%
mutate(dist_c = cumsum(d/1000),
perc_dist_c = cumsum(perc_dist),
perc_person_km_c = cumsum(perc_person_km)) %>%
# groupby so that you can apply cumsum by community
group_by(Community) %>%
mutate(dist_c_comm = cumsum(d/1000),
perc_dist_comm_c = cumsum(perc_dist_comm),
perc_person_km_comm_c = cumsum(perc_person_km_comm)) %>%
ungroup()
# add a categorical column to show which investment brack the segment is in (0:100, 100:200 etc)
grow_flow_1_seed_c$distance_groups <- cut(grow_flow_1_seed_c$dist_c, breaks = seq(from = 0, to = max(grow_flow_1_seed_c$dist_c) + 100, by = 100))
# network level plot
ggplot(data=grow_flow_1_seed_c , aes(x=dist_c, y=perc_person_km_c)) +
geom_line() +
ggtitle("Connected Growth from One Origin") +
labs(x = "Length of Investment (km)", y = "% of person km satisfied",
subtitle=expression("Segments Prioritized Based On **Flow**")) +
theme_minimal() +
theme(plot.title = element_text(size = 14)) +
theme(plot.subtitle = element_markdown(size = 10))
ggsave(paste0("../data/", chosen_city,"/Plots/Growth_Results/growth_one_seed_satisfied_km_all_flow_column.png"))
# community level plots
ggplot(data=grow_flow_1_seed_c,
aes(x=dist_c, y=perc_person_km_comm_c, group=Community, color = Community)) +
geom_line() +
ggtitle("Connected Growth from One Origin") +
labs(x = "Total Length of Investment (km)", y = "% of person km satisfied within community",
subtitle="Segments Prioritized Based On **Flow**") +
theme_minimal() +
theme(plot.title = element_text(size = 14)) +
theme(plot.subtitle = element_markdown(size = 10))
ggsave(paste0("../data/", chosen_city,"/Plots/Growth_Results/growth_one_seed_satisfied_km_community_flow_column.png"))
# we want edges added first to have a thicker lineweight. I add a column to inverse the sequence because tmap
#will automatically give higher numbers a thicker weight when passing a variable to 'lwd'
grow_flow_1_seed_c$sequen_inv <- max(grow_flow_1_seed_c$sequen) - grow_flow_1_seed_c$sequen
#### Plot with colour proportional to km (from cumulative distance column) instead of sequence  ####
tm_shape(graph_sf) +
tm_lines(col = 'gray95') +
tm_shape(grow_flow_1_seed_c) +
tm_lines(title.col = "Priority (km)",
col = 'dist_c',    # could do col='sequen' to
lwd = 'sequen_inv',
scale = 1.8,     #multiply line widths by X
palette = "-Blues",
#style = "cont",   # to get a continuous gradient and not breaks
legend.lwd.show = FALSE) +
tm_layout(title = "Growing A Network From One Seed",
title.size = 1.2,
title.color = "azure4",
title.position = c("left", "top"),
inner.margins = c(0.1, 0.1, 0.1, 0.1),    # bottom, left, top, and right margin
fontfamily = 'Georgia',
#legend.position = c("right", "bottom"),
frame = FALSE) -> p
tmap_save(tm = p, filename = paste0("../data/", chosen_city,"/Plots/Growth_Results/growth_one_seed_priority_all_FLOW.png"))
########################################### FUNCTION 2: GROWTH FROM EXISTING INFRASTRUCTURE ###########################################
# let's grow the network based on existing infrastructure
grow_flow_existing_infra <- growth_existing_infra(graph = graph_sf, km = 500, col_name = "flow")
# get % of edges in gcc
grow_flow_existing_infra$gcc_size_perc <- (grow_flow_existing_infra$gcc_size / nrow(graph_sf)) * 100
# prepare a dataframe for ggplot
grow_flow_existing_infra_c <- grow_flow_existing_infra %>%
arrange(sequen) %>%  # make sure it is arranged by sequen (Otherwise cumulative sum values will be wrong)
ungroup %>%   # not sure why it is a grouped df. This only has an effect on the select argument
filter(cycle_infra == 0) %>% # all edges with cycle infrastructure were added at the beginning
dplyr::select(Community, d, flow, highway, cycle_infra, sequen, perc_dist, perc_flow,
perc_person_km, perc_dist_comm, perc_flow_comm, perc_person_km_comm, no_components,
gcc_size, gcc_size_perc)
# We have filtered the dataframe to include only segments without cycling infrastructure. This is because we want
# to see the effect of adding these segments on the person_km satisfied. However, the initial person_km satisfied is not 0
# but equal to that satisfied by existing infrastructure. We calculate those initial values and add them to the cumulative
# percentages calculated
# get the person_km satisfied by existing infrastructure
initial_perc_satisfied_all <- grow_flow_existing_infra %>%
st_drop_geometry() %>%
filter(cycle_infra == 1) %>%
summarize(sum(perc_person_km)) %>% as.numeric()
# same as above but for each community
initial_perc_satisfied_comm <- grow_flow_existing_infra %>%
st_drop_geometry() %>%
group_by(Community) %>%
filter(cycle_infra == 1) %>%
summarize(initial_perc_satisfied = sum(perc_person_km_comm))
# join the community values so that we can add them to cumsum so that % satisfied does not start at 0
grow_flow_existing_infra_c <- grow_flow_existing_infra_c %>%
dplyr::left_join(initial_perc_satisfied_comm, by = c("Community"))
# cumsum is cumulative sum. We see how much of person_km has been satisfied after each iteration
grow_flow_existing_infra_c <- grow_flow_existing_infra_c %>%
mutate(dist_c = cumsum(d/1000),
perc_dist_c = cumsum(perc_dist),
perc_person_km_c = cumsum(perc_person_km) + initial_perc_satisfied_all) %>%
# groupby so that you can apply cumsum by community
group_by(Community) %>%
mutate(dist_c_comm = cumsum(d/1000),
perc_dist_comm_c = cumsum(perc_dist_comm),
perc_person_km_comm_c = cumsum(perc_person_km_comm) + initial_perc_satisfied) %>%
ungroup()
# add a categorical column to show which investment brack the segment is in (0:100, 100:200 etc)
grow_flow_existing_infra_c$distance_groups <- cut(grow_flow_existing_infra_c$dist_c, breaks = seq(from = 0, to = max(grow_flow_existing_infra_c$dist_c) + 100, by = 100))
# network level plot
ggplot(data=grow_flow_existing_infra_c , aes(x=dist_c, y=perc_person_km_c)) +
geom_line() +
ggtitle("Connected Growth from Existing Cycling Infrastructure") +
labs(x = "Length of Investment (km)", y = "% of person km satisfied",
subtitle=expression("Segments Prioritized Based On **Flow**")) +
theme_minimal() +
theme(plot.title = element_text(size = 14)) +
theme(plot.subtitle = element_markdown(size = 10)) +
scale_x_continuous(expand = c(0, 0), limits = c(0, NA)) +
scale_y_continuous(expand = c(0, 0), limits = c(0, 100))
ggsave(paste0("../data/", chosen_city,"/Plots/Growth_Results/growth_existing_infra_satisfied_km_all_flow_column.png"))
# community level plots
ggplot(data=grow_flow_existing_infra_c,
aes(x=dist_c, y=perc_person_km_comm_c, group=Community, color = Community)) +
geom_line() +
ggtitle("Connected Growth from Existing Cycling Infrastructure") +
labs(x = "Total Length of Investment (km)", y = "% of person km satisfied within community",
subtitle="Segments Prioritized Based On **Flow**") +
theme_minimal() +
theme(plot.title = element_text(size = 14)) +
theme(plot.subtitle = element_markdown(size = 10)) +
scale_x_continuous(expand = c(0, 0), limits = c(0, NA)) +
scale_y_continuous(expand = c(0, 0), limits = c(0, 100))
ggsave(paste0("../data/", chosen_city,"/Plots/Growth_Results/growth_existing_infra_satisfied_km_community_flow_column.png"))
# network level plot showing no of components (decreasing?) as network grows
ggplot(data=grow_flow_existing_infra_c , aes(x=dist_c, y=no_components)) +
geom_line() +
ggtitle("Number of Components Making Up Network") +
labs(x = "Length of Investment (km)", y = "No. of Components",
subtitle=expression("Segments Prioritized Based On **Flow**")) +
theme_minimal() +
theme(plot.subtitle = element_markdown())
ggsave(paste0("../data/", chosen_city,"/Plots/Growth_Results/growth_existing_infra_components_number_flow.png"))
# network level plot showing size of gcc
ggplot(data=grow_flow_existing_infra_c , aes(x=dist_c, y=gcc_size_perc)) +
geom_line() +
ggtitle("Edges in Largest Connected Component") +
labs(x = "Length of Investment (km)", y = "% of Edges in LCC",
subtitle=expression("Segments Prioritized Based On **Flow**")) +
theme_minimal() +
theme(plot.subtitle = element_markdown())
ggsave(paste0("../data/", chosen_city,"/Plots/Growth_Results/growth_existing_infra_components_gcc_flow.png"))
# inverse sequence so that thickest edges are the ones selected first
grow_flow_existing_infra_c$sequen_inv <- max(grow_flow_existing_infra_c$sequen) - grow_flow_existing_infra_c$sequen
# segments that had dedicated cycling infrastructure
initial_infra <- grow_flow_existing_infra %>% filter(cycle_infra == 1)
#### Plot with colour proportional to km (from cumulative distance column) instead of sequence  ####
tm_shape(graph_sf) +
tm_lines(col = 'gray95') +
tm_shape(initial_infra) +
tm_lines(col = 'firebrick2',
lwd = 2) +
tm_shape(grow_flow_existing_infra_c) +
tm_lines(title.col = "Priority (km)",
col = 'dist_c',    # could do col='sequen' to
lwd = 'sequen_inv',
scale = 1.8,     #multiply line widths by X
palette = "-Blues",
#style = "cont",   # to get a continuous gradient and not breaks
legend.lwd.show = FALSE) +
tm_layout(title = "Growing A Network Around Existing Cycling Infrastructure",
title.size = 1.2,
title.color = "azure4",
title.position = c("left", "top"),
inner.margins = c(0.1, 0.1, 0.1, 0.1),    # bottom, left, top, and right margin
fontfamily = 'Georgia',
#legend.position = c("left", "bottom"),
frame = FALSE) +
# add legend for the existing cycling infrastructure
tm_add_legend(type = "line", labels = 'Existing Cycling Infrastructure', col = 'firebrick2', lwd = 2) -> p
tmap_save(tm = p, filename = paste0("../data/", chosen_city,"/Plots/Growth_Results/growth_existing_infra_priority_all_FLOW.png"))
# lets show where the 1st 100km selected are (to show distribution of resources across communities)
grow_flow_existing_infra_c_100 <- grow_flow_existing_infra_c %>% dplyr::filter(dist_c <= 100)
tm_shape(graph_sf) +
tm_lines(col = 'gray95') +
tm_shape(initial_infra) +
tm_lines(col = 'firebrick2',
lwd = 1.3) +
tm_facets(by="Community",
nrow = 1,
free.coords=FALSE)  +  # so that the maps aren't different sizes
tm_shape(grow_flow_existing_infra_c_100) +
tm_lines(title.col = "Priority (km)",
col = 'dist_c',
lwd = 'sequen_inv',
scale = 1.2,     #multiply line widths by X
palette = "-Blues",
#style = "cont",   # to get a continuous gradient and not breaks
legend.lwd.show = FALSE) +
tm_facets(by="Community",
nrow = 1,
free.coords=FALSE)  +  # so that the maps aren't different sizes
tm_layout(main.title = "Distribution of Initial 100km of Investment",
main.title.size = 1.2,
main.title.color = "azure4",
main.title.position = c("left", "top"),
fontfamily = 'Georgia',
legend.outside.position = c("right", "bottom"),
frame = FALSE) +
# add legend for the existing cycling infrastructure
tm_add_legend(type = "line", labels = 'Existing Cycling Infrastructure', col = 'firebrick2', lwd = 1.5) -> p
tmap_save(tm = p, filename = paste0("../data/", chosen_city,"/Plots/Growth_Results/growth_existing_infra_facet_FLOW_100.png"),
width=10, height=4)
# clear environment
rm(graph_sf, grow_flow_1_seed, grow_flow_1_seed_c, grow_flow_existing_infra,
initial_perc_satisfied_all, initial_perc_satisfied_comm, initial_infra,
grow_flow_existing_infra_c, grow_flow_existing_infra_c_100, p)
