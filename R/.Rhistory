# You don''t need the nodes for community detection. They are used to store the community detection results
#tidygraph
nodes <- st_read(paste0("../data/", chosen_city,"/msoa_lon_lat.shp"))
edges <- read_csv(paste0("../data/", chosen_city,"/flows_for_desire_lines.csv"))
# change names of columns to from and to -> UNNECESSARY IF THEY ARE FIRST TWO COLUMNS
# edges <- edges %>% rename(from = `Area of residence`, to = `Area of workplace`)
# convert edge dataframe to graph
graph <- as_tbl_graph(edges, directed = FALSE)
# choose an a community detection algorithm and assign MSOAs to groups (weight is the flow)
graph_louvain <- graph %>%  activate(nodes) %>%
mutate(group = group_louvain(weights = `potential_demand`))
# extract nodes so that you can join group results onto the M
community_assignment <- graph_louvain %>% activate("nodes") %>% as_tibble()
# join group result to each MSOA
nodes <- nodes %>% dplyr::left_join(community_assignment, by =  c("msoa11cd" = "name"))
# count number of MSOAs in each group
nodes %>% st_drop_geometry() %>%
group_by(group) %>%
summarize(count = n()) %>% arrange(desc(count))
# read in msoa border geometry
msoa_borders <- st_read(paste0("../data/", chosen_city,"/msoas_geometry.shp"))
plot(st_geometry(msoa_borders))
plot(nodes['group'], add = TRUE)
# read in road edges with aggregated flow data
road_segments <- readRDS(paste0("../data/", chosen_city,"/graph_with_flows_default.RDS"))
#road_segments <- road_segments %>% dplyr::select(flow)
# plot
plot(st_geometry(msoa_borders))
plot(st_geometry(road_segments), add = TRUE, col = "darkred")
############### 2. ASSIGNING COMMUNITIES TO EDGES ###############
# We need to assign a community to each edge. I am doing this in two steps:
# 1. Assign each edge to an MSOA
# 2. Assign each edge to the same community of its MSOA
########## 2.1: FUNCTION FOR ASSIGNING ROAD EDGES TO MSOAS ###########
# Below function does the following:
# if road segment does not intersect with any msoa border, snap it to the nearesr msoa centroid
# if road segment interect (crosses) more than one msoa border, calculate the length of intersection with
# with all intersecting MSOAs and assign it to the one it intersect with most
# if road segment falls completely within one msoa, assign it to that msoa
assign_edge_to_polygon = function(x, y, z) {
# x = sf with linestring features (road edges)
# y = sf with polygon features (msoa borders)
# z = sf with point features (msoa centroids)
##############
#### this function requires a column in y and z named msoa11cd!!!! ####
###############
if (inherits(x, "sf")) n = nrow(x)
if (inherits(x, "sfc")) n = length(x)
out = do.call(c,
lapply(seq(n), function(i) {
# nrst is a list! It returns the msoa row number/s
nrst = st_intersects(st_geometry(x)[i], y)
# if intersect returns nothing, this edge is outside of all MSOA geometries
# get nearest msoa centroid to edge and assign it to it
if ( length (nrst[[1]]) == 0 ){
nrst = st_nearest_feature(st_geometry(x)[i], z)
msoa_code = as.character(z$msoa11cd[nrst[[1]]])
}
# if edge intersect with more than 1 msoa (does not fall completely inside 1), then
# find the length of intersection with each, and assign it to the one it intersects with more
else if ( length (nrst[[1]]) > 1 ){
# gets the msoa list position of the biggest intersection (intersection length with the different msoas is compared first)
a = which.max(st_length(st_intersection(st_geometry(x)[i], y)))
# [[1]] to get the list element with the intersecting msoas
# nrst is assigned to the msoa return from a
nrst =  nrst[[1]][a]
msoa_code = as.character(y$msoa11cd[nrst[[1]]])
}
# if edge falls completely inside 1 msoa, assign it to that msoa
else {
msoa_code = as.character(y$msoa11cd[nrst[[1]]])
}
# in all cases above, we get the msoa code by pointing to df$column[row number],
# where row number is retrieved from the nrst list through nrst[[1]]....ropey
return(msoa_code)
})
)
out = dplyr::as_tibble(out)
return(out)
}
# use function to assign each edge to an msoa. length of result = length of x
edge_msoas <- assign_edge_to_polygon(x =road_segments, y = msoa_borders, z = nodes)
# rename the column before binding
edge_msoas <- edge_msoas %>% rename(assigned_msoa = value)
# bind results to original road_segments sf
road_segments <- dplyr::bind_cols(road_segments, edge_msoas)
# plot for quick inspection
plot(st_geometry(msoa_borders))
plot(st_geometry(nodes), col = "grey", add = TRUE)
plot(road_segments['assigned_msoa'], add=TRUE)
###### 2.2: ASSIGN EACH EDGE TO THE SAME COMMUNITY AS ITS ASSOCIATED MSOA #######
road_segments <- road_segments %>% dplyr::left_join(community_assignment, by =  c("assigned_msoa" = "name"))
# quick plot
plot(road_segments['group'])
#################### 3. MAPPING  ######################
# 3.1. map of msoa centroids colored by community
# convert to character for legend
nodes$Community <- as.character(nodes$group)
tm_shape(msoa_borders) +
tm_borders(col = "grey80") +
tm_shape(nodes) +
tm_dots(col = "Community",
size = 0.1,
palette = "Dark2") +
tm_layout(fontfamily = 'Georgia',
legend.show = FALSE,
frame = FALSE) -> tm1
# 3.2. map of road segments colored by community
# convert group column to categorical so that we don't get 1-1.5, 2-2.5 etc in the legend
road_segments$Community <- as.character(road_segments$group)
tm_shape(road_segments) +
tm_lines(#title = "Community",
col = "Community",
palette = "Dark2") +
tm_layout(fontfamily = 'Georgia',
legend.show =FALSE,
frame = FALSE) -> tm2
# 3.3  get legend only for facet map
tm_shape(road_segments) +
tm_lines(col = "Community",
palette = "Dark2") +
tm_layout(fontfamily = 'Georgia',
legend.only=TRUE,
frame = FALSE) -> tm_leg
# can do a tmap arrange here but am I bovered?!
tm_facet <- tmap_arrange(tm1, tm2, tm_leg, nrow=1)
#save
tmap_save(tm = tm_facet, filename = paste0("../data/", chosen_city,"/Plots/communities.png"),
width=8.5, height=4)
# 3.4  MSOAs as cloropleth/choropleth/whatever
# add communitiy column to polygon geometry to create cloropleth map
msoa_borders <- nodes %>%
st_drop_geometry %>%
dplyr::select(msoa11cd, Community) %>%
right_join(msoa_borders, by = 'msoa11cd') %>%
st_as_sf()
tm_shape(msoa_borders) +
tm_fill(col = "Community",
palette = "Dark2") +
tm_layout(fontfamily = 'Georgia',
legend.show = FALSE,
frame = FALSE) -> tm3
tm_facet2 <- tmap_arrange(tm3, tm2, tm_leg, nrow=1)
tmap_save(tm = tm_facet2, filename = paste0("../data/", chosen_city,"/Plots/communities_alternative.png"),
width=8.5, height=4)
# save road_segments as an RDS to work with in the next script
saveRDS(road_segments, file = paste0("../data/", chosen_city, "/graph_with_flows_default_communities.Rds"))
# CLEAR ENVIRONMENT!!!
rm(community_assignment, edge_msoas, edges, graph, graph_louvain, msoa_borders, nodes, road_segments,
tm_facet, tm_facet2, tm_leg, tm1, tm2, tm3, assign_edge_to_polygon)
# to check which features do not intersect at all with MSOAS #id:423
# mapview::mapview(road_segments, zcol="assigned_msoa") +
#   mapview::mapview(msoa_borders)
graph_sf <- readRDS(paste0("../data/", chosen_city, "/graph_with_flows_default_communities.RDS"))
View(graph_sf)
library(sf)
library(tidyverse)
library(ggtext)
library(tmap)
graph_sf <- readRDS(paste0("../data/", chosen_city, "/graph_with_flows_default_communities.RDS"))
# we weigh the flow on each edge by its distance. We can then get how much of the commuter km are satisfied
graph_sf$person_km <- graph_sf$flow * graph_sf$d
########## GGPLOTS SHOWING FLOW/PERSON_KM SATISFIED AT THE NETWORK LEVEL AND AT THE COMMUNITY LEVEL #############
# get percentage contibution of each edge to the network (distance, flow, person_km)
graph_sf <- graph_sf %>%
mutate(perc_dist = (d/sum(d))  *100,      # edge length as % of total network length
perc_flow = (flow/sum(flow))  *100, # flow on edge as % of total
perc_person_km = (person_km/sum(person_km))  *100) %>% # % of person_km satisfied
# get the same % for each community as a % of the community totals
group_by(Community) %>%
mutate(perc_dist_comm = (d/sum(d)) * 100,
perc_flow_comm = (flow/sum(flow))  *100,
perc_person_km_comm = (person_km/sum(person_km))  *100) %>%
ungroup()
########################################### FUNCTION 1: GROWTH FROM ONE SEED/EDGE ###########################################
# let's grow the network based on the flow column
grow_flow_1_seed <- growth_one_seed(graph = graph_sf, km = 500, col_name = "flow")
# prepare a dataframe for plotting the results
grow_flow_1_seed_c <- grow_flow_1_seed %>%
ungroup %>%   # not sure why it is a grouped df. This only has an effect on the select argument
#st_drop_geometry() %>%
dplyr::select(Community, d, flow, cycle_infra, sequen, perc_dist, perc_flow,
perc_person_km, perc_dist_comm, perc_flow_comm, perc_person_km_comm, highway)
# cumsum is cumulative sum. We see how much of person_km has been satisfied after each iteration
grow_flow_1_seed_c <- grow_flow_1_seed_c %>%
mutate(dist_c = cumsum(d/1000),
perc_dist_c = cumsum(perc_dist),
perc_person_km_c = cumsum(perc_person_km)) %>%
# groupby so that you can apply cumsum by community
group_by(Community) %>%
mutate(dist_c_comm = cumsum(d/1000),
perc_dist_comm_c = cumsum(perc_dist_comm),
perc_person_km_comm_c = cumsum(perc_person_km_comm))
# add a categorical column to show which investment brack the segment is in (0:100, 100:200 etc)
grow_flow_1_seed_c$distance_groups <- cut(grow_flow_1_seed_c$dist_c, breaks = seq(from = 0, to = max(grow_flow_1_seed_c$dist_c) + 100, by = 100))
# network level plot
ggplot(data=grow_flow_1_seed_c , aes(x=dist_c, y=perc_person_km_c)) +
geom_line() +
ggtitle("Connected Growth from One Origin") +
labs(x = "Length of Investment (km)", y = "% of person km satisfied",
subtitle=expression("Segments Prioritized Based On **Flow**")) +
theme_minimal() +
theme(plot.title = element_text(size = 14)) +
theme(plot.subtitle = element_markdown(size = 10))
ggsave(paste0("../data/", chosen_city,"/Plots/Growth_Results/growth_one_seed_satisfied_km_all_flow_column.png"))
# community level plots
ggplot(data=grow_flow_1_seed_c,
aes(x=dist_c, y=perc_person_km_comm_c, group=Community, color = Community)) +
geom_line() +
ggtitle("Connected Growth from One Origin") +
labs(x = "Total Length of Investment (km)", y = "% of person km satisfied within community",
subtitle="Segments Prioritized Based On **Flow**") +
theme_minimal() +
theme(plot.title = element_text(size = 14)) +
theme(plot.subtitle = element_markdown(size = 10))
ggsave(paste0("../data/", chosen_city,"/Plots/Growth_Results/growth_one_seed_satisfied_km_community_flow_column.png"))
# we want edges added first to have a thicker lineweight. I add a column to inverse the sequence because tmap
#will automatically give higher numbers a thicker weight when passing a variable to 'lwd'
grow_flow_1_seed_c$sequen_inv <- max(grow_flow_1_seed_c$sequen) - grow_flow_1_seed_c$sequen
#### Plot with colour proportional to km (from cumulative distance column) instead of sequence  ####
tm_shape(graph_sf) +
tm_lines(col = 'gray95') +
tm_shape(grow_flow_1_seed_c) +
tm_lines(title.col = "Priority (km)",
col = 'dist_c',    # could do col='sequen' to
lwd = 'sequen_inv',
scale = 1.8,     #multiply line widths by X
palette = "-Blues",
#style = "cont",   # to get a continuous gradient and not breaks
legend.lwd.show = FALSE) +
tm_layout(title = "Growing A Network From One Seed",
title.size = 1.2,
title.color = "azure4",
title.position = c("left", "top"),
inner.margins = c(0.1, 0.1, 0.1, 0.1),    # bottom, left, top, and right margin
fontfamily = 'Georgia',
legend.position = c("right", "bottom"),
frame = FALSE) -> p
tmap_save(tm = p, filename = paste0("../data/", chosen_city,"/Plots/Growth_Results/growth_one_seed_priority_all_FLOW.png"))
########################################### FUNCTION 2: GROWTH FROM EXISTING INFRASTRUCTURE ###########################################
# let's grow the network based on existing infrastructure
grow_flow_existing_infra <- growth_existing_infra(graph = graph_sf, km = 500, col_name = "flow")
# get % of edges in gcc
grow_flow_existing_infra$gcc_size_perc <- (grow_flow_existing_infra$gcc_size / nrow(graph_sf)) * 100
# prepare a dataframe for ggplot
grow_flow_existing_infra_c <- grow_flow_existing_infra %>%
ungroup %>%   # not sure why it is a grouped df. This only has an effect on the select argument
filter(cycle_infra == 0) %>% # all edges with cycle infrastructure were added at the beginning
dplyr::select(Community, d, flow, highway, cycle_infra, sequen, perc_dist, perc_flow,
perc_person_km, perc_dist_comm, perc_flow_comm, perc_person_km_comm, no_components,
gcc_size, gcc_size_perc)
# We have filtered the dataframe to include only segments without cycling infrastructure. This is because we want
# to see the effect of adding these segments on the person_km satisfied. However, the initial person_km satisfied is not 0
# but equal to that satisfied by existing infrastructure. We calculate those initial values and add them to the cumulative
# percentages calculated
# get the person_km satisfied by existing infrastructure
initial_perc_satisfied_all <- grow_flow_existing_infra %>%
st_drop_geometry() %>%
filter(cycle_infra == 1) %>%
summarize(sum(perc_person_km)) %>% as.numeric()
# same as above but for each community
initial_perc_satisfied_comm <- grow_flow_existing_infra %>%
st_drop_geometry() %>%
group_by(Community) %>%
filter(cycle_infra == 1) %>%
summarize(initial_perc_satisfied = sum(perc_person_km_comm))
# join the community values so that we can add them to cumsum so that % satisfied does not start at 0
grow_flow_existing_infra_c <- grow_flow_existing_infra_c %>%
dplyr::left_join(initial_perc_satisfied_comm, by = c("Community"))
# cumsum is cumulative sum. We see how much of person_km has been satisfied after each iteration
grow_flow_existing_infra_c <- grow_flow_existing_infra_c %>%
mutate(dist_c = cumsum(d/1000),
perc_dist_c = cumsum(perc_dist),
perc_person_km_c = cumsum(perc_person_km) + initial_perc_satisfied_all) %>%
# groupby so that you can apply cumsum by community
group_by(Community) %>%
mutate(dist_c_comm = cumsum(d/1000),
perc_dist_comm_c = cumsum(perc_dist_comm),
perc_person_km_comm_c = cumsum(perc_person_km_comm) + initial_perc_satisfied)
# add a categorical column to show which investment brack the segment is in (0:100, 100:200 etc)
grow_flow_existing_infra_c$distance_groups <- cut(grow_flow_existing_infra_c$dist_c, breaks = seq(from = 0, to = max(grow_flow_existing_infra_c$dist_c) + 100, by = 100))
# network level plot
ggplot(data=grow_flow_existing_infra_c , aes(x=dist_c, y=perc_person_km_c)) +
geom_line() +
ggtitle("Connected Growth from Existing Cycling Infrastructure") +
labs(x = "Length of Investment (km)", y = "% of person km satisfied",
subtitle=expression("Segments Prioritized Based On **Flow**")) +
theme_minimal() +
theme(plot.title = element_text(size = 14)) +
theme(plot.subtitle = element_markdown(size = 10)) +
scale_x_continuous(expand = c(0, 0), limits = c(0, NA)) +
scale_y_continuous(expand = c(0, 0), limits = c(0, 100))
ggsave(paste0("../data/", chosen_city,"/Plots/Growth_Results/growth_existing_infra_satisfied_km_all_flow_column.png"))
# community level plots
ggplot(data=grow_flow_existing_infra_c,
aes(x=dist_c, y=perc_person_km_comm_c, group=Community, color = Community)) +
geom_line() +
ggtitle("Connected Growth from Existing Cycling Infrastructure") +
labs(x = "Total Length of Investment (km)", y = "% of person km satisfied within community",
subtitle="Segments Prioritized Based On **Flow**") +
theme_minimal() +
theme(plot.title = element_text(size = 14)) +
theme(plot.subtitle = element_markdown(size = 10)) +
scale_x_continuous(expand = c(0, 0), limits = c(0, NA)) +
scale_y_continuous(expand = c(0, 0), limits = c(0, 100))
ggsave(paste0("../data/", chosen_city,"/Plots/Growth_Results/growth_existing_infra_satisfied_km_community_flow_column.png"))
# network level plot showing no of components (decreasing?) as network grows
ggplot(data=grow_flow_existing_infra_c , aes(x=dist_c, y=no_components)) +
geom_line() +
ggtitle("Number of Components Making Up Network") +
labs(x = "Length of Investment (km)", y = "No. of Components",
subtitle=expression("Segments Prioritized Based On **Flow**")) +
theme_minimal() +
theme(plot.subtitle = element_markdown())
ggsave(paste0("../data/", chosen_city,"/Plots/Growth_Results/growth_existing_infra_components_number_flow.png"))
# network level plot showing size of gcc
ggplot(data=grow_flow_existing_infra_c , aes(x=dist_c, y=gcc_size_perc)) +
geom_line() +
ggtitle("Edges in Largest Connected Component") +
labs(x = "Length of Investment (km)", y = "% of Edges in LCC",
subtitle=expression("Segments Prioritized Based On **Flow**")) +
theme_minimal() +
theme(plot.subtitle = element_markdown())
ggsave(paste0("../data/", chosen_city,"/Plots/Growth_Results/growth_existing_infra_components_gcc_flow.png"))
# inverse sequence so that thickest edges are the ones selected first
grow_flow_existing_infra_c$sequen_inv <- max(grow_flow_existing_infra_c$sequen) - grow_flow_existing_infra_c$sequen
# segments that had dedicated cycling infrastructure
initial_infra <- grow_flow_existing_infra %>% filter(cycle_infra == 1)
#### Plot with colour proportional to km (from cumulative distance column) instead of sequence  ####
tm_shape(graph_sf) +
tm_lines(col = 'gray95') +
tm_shape(initial_infra) +
tm_lines(col = 'firebrick2',
lwd = 2) +
tm_shape(grow_flow_existing_infra_c) +
tm_lines(title.col = "Priority (km)",
col = 'dist_c',    # could do col='sequen' to
lwd = 'sequen_inv',
scale = 1.8,     #multiply line widths by X
palette = "-Blues",
#style = "cont",   # to get a continuous gradient and not breaks
legend.lwd.show = FALSE) +
tm_layout(title = "Growing A Network Around Existing Cycling Infrastructure",
title.size = 1.2,
title.color = "azure4",
title.position = c("left", "top"),
inner.margins = c(0.1, 0.1, 0.1, 0.1),    # bottom, left, top, and right margin
fontfamily = 'Georgia',
legend.position = c("right", "bottom"),
frame = FALSE) +
# add legend for the existing cycling infrastructure
tm_add_legend(type = "line", labels = 'Existing Cycling Infrastructure', col = 'firebrick2', lwd = 2) -> p
tmap_save(tm = p, filename = paste0("../data/", chosen_city,"/Plots/Growth_Results/growth_existing_infra_priority_all_FLOW.png"))
# lets show where the 1st 100km selected are (to show distribution of resources across communities)
grow_flow_existing_infra_c_100 <- grow_flow_existing_infra_c %>% dplyr::filter(dist_c <= 100)
tm_shape(graph_sf) +
tm_lines(col = 'gray95') +
tm_shape(initial_infra) +
tm_lines(col = 'firebrick2',
lwd = 1.5) +
tm_facets(by="Community",
nrow = 1,
free.coords=FALSE)  +  # so that the maps aren't different sizes
tm_shape(grow_flow_existing_infra_c_100) +
tm_lines(title.col = "Priority (km)",
col = 'dist_c',
lwd = 'sequen_inv',
scale = 1.2,     #multiply line widths by X
palette = "-Blues",
#style = "cont",   # to get a continuous gradient and not breaks
legend.lwd.show = FALSE) +
tm_facets(by="Community",
nrow = 1,
free.coords=FALSE)  +  # so that the maps aren't different sizes
tm_layout(main.title = "Distribution of Initial 100km of Investment",
main.title.size = 1.2,
main.title.color = "azure4",
main.title.position = c("left", "top"),
fontfamily = 'Georgia',
legend.outside.position = c("right", "bottom"),
frame = FALSE) +
# add legend for the existing cycling infrastructure
tm_add_legend(type = "line", labels = 'Existing Cycling Infrastructure', col = 'firebrick2', lwd = 1.5) -> p
tmap_save(tm = p, filename = paste0("../data/", chosen_city,"/Plots/Growth_Results/growth_existing_infra_facet_FLOW_100.png"),
width=10, height=4)
View(grow_flow_1_seed_c)
class(graph_sf)
class(graph_flow_1_seed)
class(grow_flow_1_seed)
class(grow_flow_1_seed_c)
#### Plot with colour proportional to km (from cumulative distance column) instead of sequence  ####
tm_shape(graph_sf) +
tm_lines(col = 'gray95') +
tm_shape(grow_flow_1_seed_c) +
tm_lines(title.col = "Priority (km)",
col = 'dist_c',    # could do col='sequen' to
lwd = 'sequen_inv',
scale = 1.8,     #multiply line widths by X
palette = "-Blues",
#style = "cont",   # to get a continuous gradient and not breaks
legend.lwd.show = FALSE) +
tm_layout(title = "Growing A Network From One Seed",
title.size = 1.2,
title.color = "azure4",
title.position = c("left", "top"),
inner.margins = c(0.1, 0.1, 0.1, 0.1),    # bottom, left, top, and right margin
fontfamily = 'Georgia',
legend.position = c("right", "bottom"),
frame = FALSE) -> p
#### Plot with colour proportional to km (from cumulative distance column) instead of sequence  ####
tm_shape(graph_sf) +
tm_lines(col = 'gray95') +
tm_shape(grow_flow_1_seed_c) +
tm_lines(title.col = "Priority (km)",
col = 'dist_c',    # could do col='sequen' to
lwd = 'sequen_inv',
scale = 1.8,     #multiply line widths by X
palette = "-Blues",
#style = "cont",   # to get a continuous gradient and not breaks
legend.lwd.show = FALSE) +
tm_layout(title = "Growing A Network From One Seed",
title.size = 1.2,
title.color = "azure4",
title.position = c("left", "top"),
inner.margins = c(0.1, 0.1, 0.1, 0.1),    # bottom, left, top, and right margin
fontfamily = 'Georgia',
legend.position = c("right", "bottom"),
frame = FALSE) #-> p
# prepare a dataframe for plotting the results
grow_flow_1_seed_c <- grow_flow_1_seed %>%
ungroup %>%   # not sure why it is a grouped df. This only has an effect on the select argument
#st_drop_geometry() %>%
dplyr::select(Community, d, flow, cycle_infra, sequen, perc_dist, perc_flow,
perc_person_km, perc_dist_comm, perc_flow_comm, perc_person_km_comm, highway)
# cumsum is cumulative sum. We see how much of person_km has been satisfied after each iteration
grow_flow_1_seed_c <- grow_flow_1_seed_c %>%
mutate(dist_c = cumsum(d/1000),
perc_dist_c = cumsum(perc_dist),
perc_person_km_c = cumsum(perc_person_km)) %>%
# groupby so that you can apply cumsum by community
group_by(Community) %>%
mutate(dist_c_comm = cumsum(d/1000),
perc_dist_comm_c = cumsum(perc_dist_comm),
perc_person_km_comm_c = cumsum(perc_person_km_comm)) %>%
ungroup()
class(grow_flow_1_seed_c)
# add a categorical column to show which investment brack the segment is in (0:100, 100:200 etc)
grow_flow_1_seed_c$distance_groups <- cut(grow_flow_1_seed_c$dist_c, breaks = seq(from = 0, to = max(grow_flow_1_seed_c$dist_c) + 100, by = 100))
# network level plot
ggplot(data=grow_flow_1_seed_c , aes(x=dist_c, y=perc_person_km_c)) +
geom_line() +
ggtitle("Connected Growth from One Origin") +
labs(x = "Length of Investment (km)", y = "% of person km satisfied",
subtitle=expression("Segments Prioritized Based On **Flow**")) +
theme_minimal() +
theme(plot.title = element_text(size = 14)) +
theme(plot.subtitle = element_markdown(size = 10))
ggsave(paste0("../data/", chosen_city,"/Plots/Growth_Results/growth_one_seed_satisfied_km_all_flow_column.png"))
# community level plots
ggplot(data=grow_flow_1_seed_c,
aes(x=dist_c, y=perc_person_km_comm_c, group=Community, color = Community)) +
geom_line() +
ggtitle("Connected Growth from One Origin") +
labs(x = "Total Length of Investment (km)", y = "% of person km satisfied within community",
subtitle="Segments Prioritized Based On **Flow**") +
theme_minimal() +
theme(plot.title = element_text(size = 14)) +
theme(plot.subtitle = element_markdown(size = 10))
ggsave(paste0("../data/", chosen_city,"/Plots/Growth_Results/growth_one_seed_satisfied_km_community_flow_column.png"))
# we want edges added first to have a thicker lineweight. I add a column to inverse the sequence because tmap
#will automatically give higher numbers a thicker weight when passing a variable to 'lwd'
grow_flow_1_seed_c$sequen_inv <- max(grow_flow_1_seed_c$sequen) - grow_flow_1_seed_c$sequen
#### Plot with colour proportional to km (from cumulative distance column) instead of sequence  ####
tm_shape(graph_sf) +
tm_lines(col = 'gray95') +
tm_shape(grow_flow_1_seed_c) +
tm_lines(title.col = "Priority (km)",
col = 'dist_c',    # could do col='sequen' to
lwd = 'sequen_inv',
scale = 1.8,     #multiply line widths by X
palette = "-Blues",
#style = "cont",   # to get a continuous gradient and not breaks
legend.lwd.show = FALSE) +
tm_layout(title = "Growing A Network From One Seed",
title.size = 1.2,
title.color = "azure4",
title.position = c("left", "top"),
inner.margins = c(0.1, 0.1, 0.1, 0.1),    # bottom, left, top, and right margin
fontfamily = 'Georgia',
legend.position = c("right", "bottom"),
frame = FALSE) #-> p
plot(grow_flow_1_seed_c['sequen'])
#### Plot with colour proportional to km (from cumulative distance column) instead of sequence  ####
tm_shape(graph_sf) +
tm_lines(col = 'gray95') +
tm_shape(grow_flow_1_seed_c) +
tm_lines(title.col = "Priority (km)",
col = 'dist_c',    # could do col='sequen' to
lwd = 'sequen_inv',
scale = 1.8,     #multiply line widths by X
palette = "-Blues",
#style = "cont",   # to get a continuous gradient and not breaks
legend.lwd.show = FALSE) +
tm_layout(title = "Growing A Network From One Seed",
title.size = 1.2,
title.color = "azure4",
title.position = c("left", "top"),
inner.margins = c(0.1, 0.1, 0.1, 0.1),    # bottom, left, top, and right margin
fontfamily = 'Georgia',
legend.position = c("right", "bottom"),
frame = FALSE) -> p
tmap_save(tm = p, filename = paste0("../data/", chosen_city,"/Plots/Growth_Results/growth_one_seed_priority_all_FLOW.png"))
