#                   from = from, to = to, flows = od_flow_matrix,
#                   contract = TRUE, quiet = FALSE)
#
# # Turn into undirected graph
# graph_undir <- dodgr::merge_directed_flows(graph_flows)
#
# # convert to sf for prioritixing segments.
# # Notice that the segments are merged (much less than graph_flows)
# graph_sf_default <- graph_undir %>% dodgr_to_sf()
# function to merge flows, turn into undirected graph, then to sf
aggregate_flows <- function(graph, from, to, flows){
# add flows to road segments
graph_flows <- dodgr_flows_aggregate(
graph = graph,
from = from,
to = to,
flows = flows,
contract = TRUE,
quiet = FALSE)
# turn into undirected graph
graph_undir <- dodgr::merge_directed_flows(graph_flows)
# convert to sf
graph_sf <- graph_undir %>% dodgr_to_sf()
return(graph_sf)
}
# Use function to aggregate flows on graphs
# graph with default weights
graph_sf_default <- aggregate_flows(graph=graph_default, from=from, to=to, flows=od_flow_matrix)
# unweighted graph
graph_sf_unweight <- aggregate_flows(graph=graph_unweighted, from=from, to=to, flows=od_flow_matrix)
# graph with modified trunk weight
graph_sf_trunk <- aggregate_flows(graph=graph_trunk, from=from, to=to, flows=od_flow_matrix)
# save as RDS to load in next script (geojson, shp etc cause problems)
saveRDS(graph_sf_default, file = paste0("../data/", chosen_city, "/graph_with_flows_default.Rds"))
saveRDS(graph_sf_unweight, file = paste0("../data/", chosen_city, "/graph_with_flows_unweighted.Rds"))
saveRDS(graph_sf_trunk, file = paste0("../data/", chosen_city, "/graph_with_flows_trunk.Rds"))
# Plot the different results to compare. DO IT HERE NOT AFTER. IT DOESN't MATTER THAT CYCLEWAYS
# AREN'T COMPREHENSIVE IN DETERMINE BICYCLE INFRASTRUCTURE. WE ARE LOOKING AT THE EFFECTS OF WEIGHTS
# ON ROUTING
# See % of flow on cycleways, trunk ets
rm(from, graph_default, graph_sf_default, graph_sf_trunk, graph_sf_unweight,
graph_trunk, graph_unweighted, lon_lat, od_flow, od_flow_matrix, streetnet_sc,
to, aggregate_flows)
# function to merge flows, turn into undirected graph, then to sf
aggregate_flows <- function(graph, from, to, flows){
# add flows to road segments
graph_flows <- dodgr_flows_aggregate(
graph = graph,
from = from,
to = to,
flows = flows,
contract = TRUE,
quiet = FALSE)
# turn into undirected graph
graph_undir <- dodgr::merge_directed_flows(graph_flows)
# convert to sf
graph_sf <-  dodgr::dodgr_to_sf(graph_undir)
return(graph_sf)
}
library(tidyverse)
library(sf)
library(dodgr)
# read in MSOA centroids
lon_lat <- st_read(paste0("../data/",chosen_city,'/msoa_lon_lat.shp'))
# flow data: there are 3 files (check script 3 and choose 1)
od_flow <- read_csv(paste0("../data/",chosen_city,'/flows_for_aggregated_routing_opt_3.csv'))
# remove flows where ORIGIN = DESTINATION
od_flow <- od_flow %>% filter(`Area of residence` != `Area of workplace`)
# tranform into distance matrix for routing.
# column_to_rownames added so that 1st column is not the MSOA names. It assigns the MSOA names to the row ID
od_flow_matrix <-
od_flow %>%
pivot_wider(names_from = `Area of workplace`, values_from = potential_demand) %>%
tibble::column_to_rownames(var = "Area of residence") %>%
replace(is.na(.), 0) %>% as.matrix()
# last line gives 0 values to intra flows, as NAs would cause problems
# This doesn't matter in calculations as intra flows aren't aggregated on road segments
# 'from' is the 1st Column - get the MSOA names using rownames and join them with the coordinates in lon_lat
from <- rownames(od_flow_matrix) %>% as.data.frame() %>% left_join(lon_lat, by = c("." = "msoa11cd")) %>%
dplyr::select(lon, lat) %>% as.matrix()
# same as above but 'to is the column names(i.e. index row)
to <- colnames(od_flow_matrix) %>% as.data.frame() %>% left_join(lon_lat, by = c("." = "msoa11cd")) %>%
dplyr::select(lon, lat) %>% as.matrix()
# # subsets for testing (THIS WORKS)
# from2 <- rownames(od_flow_matrix) %>% as.data.frame() %>% left_join(lon_lat, by = c("." = "MSOA11CD")) %>%
#   dplyr::select(lon, lat) %>% slice(1:10) %>% as.matrix()
# to2 <- colnames(od_flow_matrix) %>% as.data.frame() %>% left_join(lon_lat, by = c("." = "MSOA11CD")) %>%
#   dplyr::select(lon, lat) %>% slice(1:10) %>% as.matrix()
#   # select first 10 rows then 1st 10 columns
# od_flow_matrix_2 <- od_flow_matrix %>% as.data.frame() %>% slice(1:10) %>% select(1:10) %>% as.matrix()
# ROUTE
# load in graph save in script 2
#graph <- readRDS(paste0("../data/",chosen_city,"/city_graph.Rds"))
streetnet_sc <- readRDS(paste0("../data/",chosen_city,"/unweighted_streetnet.Rds"))
######
# CREATE GRAPHS WITH DIFFERENT WEIGHTING PROFILES. THE WEIGHTING PROFILES ARE EDITED BY
# DOWNLOADING THE JSON IN -x-dodgr_weight_profiles.R AND EDITING IN A TEXT EDITOR
# this graph has the default dodgr weights for bicycle
graph_default <- weight_streetnet(streetnet_sc, wt_profile= "bicycle")
# all road types are weighted equally here. We use these weights to get the absolute shortest paths
graph_unweighted <- weight_streetnet(streetnet_sc,
wt_profile_file = "../data/weight_profile_shortest_path.json")
# Here trunk roads are changed from 0.3 to 0.7 (equal to primary). The idea is that segregated
# bicycle lanes can easily be built on trunk roads (park lane, euston road), so this helps determine
# which trunk routes would be useful for cyclists
graph_trunk <- weight_streetnet(streetnet_sc,
wt_profile_file = "../data/weight_profile_trunk.json")
# # add flows to road segments
# graph_flows <- dodgr_flows_aggregate(
#                   graph = graph_default,
#                   from = from, to = to, flows = od_flow_matrix,
#                   contract = TRUE, quiet = FALSE)
#
# # Turn into undirected graph
# graph_undir <- dodgr::merge_directed_flows(graph_flows)
#
# # convert to sf for prioritixing segments.
# # Notice that the segments are merged (much less than graph_flows)
# graph_sf_default <- graph_undir %>% dodgr_to_sf()
# function to merge flows, turn into undirected graph, then to sf
aggregate_flows <- function(graph, from, to, flows){
# add flows to road segments
graph_flows <- dodgr::dodgr_flows_aggregate(
graph = graph,
from = from,
to = to,
flows = flows,
contract = TRUE,
quiet = FALSE)
# turn into undirected graph
graph_undir <- dodgr::merge_directed_flows(graph_flows)
# convert to sf
graph_sf <-  dodgr::dodgr_to_sf(graph_undir)
return(graph_sf)
}
# Use function to aggregate flows on graphs
# graph with default weights
graph_sf_default <- aggregate_flows(graph=graph_default, from=from, to=to, flows=od_flow_matrix)
# unweighted graph
graph_sf_unweight <- aggregate_flows(graph=graph_unweighted, from=from, to=to, flows=od_flow_matrix)
# graph with modified trunk weight
graph_sf_trunk <- aggregate_flows(graph=graph_trunk, from=from, to=to, flows=od_flow_matrix)
# save as RDS to load in next script (geojson, shp etc cause problems)
saveRDS(graph_sf_default, file = paste0("../data/", chosen_city, "/graph_with_flows_default.Rds"))
saveRDS(graph_sf_unweight, file = paste0("../data/", chosen_city, "/graph_with_flows_unweighted.Rds"))
saveRDS(graph_sf_trunk, file = paste0("../data/", chosen_city, "/graph_with_flows_trunk.Rds"))
# Plot the different results to compare. DO IT HERE NOT AFTER. IT DOESN't MATTER THAT CYCLEWAYS
# AREN'T COMPREHENSIVE IN DETERMINE BICYCLE INFRASTRUCTURE. WE ARE LOOKING AT THE EFFECTS OF WEIGHTS
# ON ROUTING
# See % of flow on cycleways, trunk ets
rm(from, graph_default, graph_sf_default, graph_sf_trunk, graph_sf_unweight,
graph_trunk, graph_unweighted, lon_lat, od_flow, od_flow_matrix, streetnet_sc,
to, aggregate_flows)
library(sf)
library(dodgr)
library(tidyverse)
# IDENTIFY ALL ROAD SEGMENTS WITH DEDICATED CYCLING INFRASTRUCTURE
########
# Get road network through dodgr
########
# centroids for bounding box of chosen city
msoa_centroids <- st_read(paste0("../data/", chosen_city,"/msoa_lon_lat.shp"))
# bounding box
pts <- st_coordinates (msoa_centroids)
#this downloads all the road data from OSM (equivalent to : key = 'highway')
streetnet <- dodgr_streetnet(pts = pts, expand = 0.05)
# filter out useful columns
streetnet2 <- streetnet %>%
dplyr::select(osm_id, bicycle, cycleway, highway,
lanes, maxspeed, segregated)
# add length column
streetnet2 <- streetnet2 %>% dplyr::mutate(length_m = st_length(.))
########
# Check which OSM tags are useful for identifying existence of bicycle infrastructure
########
# check different columns
bicycle <- streetnet2 %>%
st_drop_geometry() %>%
group_by(bicycle) %>%
summarize(segments=n(), length_m = sum(length_m))
cycleway <- streetnet2 %>%
st_drop_geometry() %>%
group_by(cycleway) %>%
summarize(segments=n(), length_m = sum(length_m))
highway <- streetnet2 %>%
st_drop_geometry() %>%
group_by(highway) %>%
summarize(segments=n(), length_m = sum(length_m))
# MOST ARE NA
lanes <- streetnet2 %>%
st_drop_geometry() %>%
group_by(lanes) %>%
summarize(segments=n(), length_m = sum(length_m))
# MOST ARE NA
maxspeed <- streetnet2 %>%
st_drop_geometry() %>%
group_by(maxspeed) %>%
summarize(segments=n(), length_m = sum(length_m))
# MOST ARE NA
segregated <- streetnet2 %>%
st_drop_geometry() %>%
group_by(segregated) %>%
summarize(segments=n(), length_m = sum(length_m))
########
# Identify all road segments with cycling infrastructure
########
# Read in the graph with the road network and flows
graph_sf <- readRDS(paste0("../data/", chosen_city,"/graph_with_flows_default.RDS"))
# this is all road segments with bicycle == 'designated'
cycle_designated <- streetnet2 %>%
filter(bicycle == 'designated') %>%
st_combine()  # combine them into one geometry for st_within argument
# Get all features of graph_sf that are within (completely overlap with) cycle_designated
sel_sgbp <- st_within(x=graph_sf, y=cycle_designated)
sel_logical <- lengths(sel_sgbp) > 0
# subset graph_sf to edges with cycle_designated
cycle_designated <- graph_sf[sel_logical, ]
# plot to show
plot(st_geometry(graph_sf), col='lightgrey')
plot(st_geometry(cycle_designated), add=TRUE)
# this is all road segments with highway == 'cycleway'
cycleways <- streetnet2 %>%
filter(highway == 'cycleway') %>%
st_combine()
# Get all features of graph_sf that are within (completely overlap with) cycleways
sel_sgbp <- st_within(x=graph_sf, y=cycleways)
sel_logical <- lengths(sel_sgbp) > 0
# subset graph_sf to edges with cycleways
cycleways <- graph_sf[sel_logical, ]
# plot to show
plot(st_geometry(graph_sf), col='lightgrey')
plot(st_geometry(cycleways), add=TRUE)
# Show that cycle_designated is not completely contained within cycleways.
plot(st_geometry(graph_sf), col='lightgrey')
plot(st_geometry(cycle_designated), add=TRUE, col='darkred')
plot(st_geometry(cycleways), add=TRUE, col='green')
# create a combined geometry with all edges matching either of the two conditions
# highway == 'cycleway' | bicycle == 'designated'. Since we know that that neigher of them
# completely contains the other
graph_sf_cycle <- streetnet2 %>%
filter(highway == 'cycleway' | bicycle == 'designated') %>%
st_combine()
# Get all features of graph_sf that have dedicated cycling infrastructure
sel_sgbp <- st_within(x=graph_sf, y=graph_sf_cycle)
sel_logical <- lengths(sel_sgbp) > 0
graph_sf_cycle <- graph_sf[sel_logical, ]
# plot
plot(st_geometry(graph_sf), col='lightgrey')
plot(st_geometry(graph_sf_cycle), add=TRUE, col='red')
# check length of cycling infrastructure
sum(graph_sf$d)
sum(graph_sf_cycle$d)
# We need to add a column in graph_sf to identify all edges with cycle infrastructure
# add a cycle_infra column to graph_sf_cycle and give all edges a value of 1, then
# join with graph_sf
graph_sf_cycle <-
graph_sf_cycle %>% st_drop_geometry() %>%
mutate(cycle_infra= 1) %>%
dplyr::select(c(edge_id, cycle_infra))
# this will add the cycle_infra column to the original graph_sf
graph_sf <- dplyr::left_join(graph_sf, graph_sf_cycle, by = "edge_id")
# all NA values in cycle_infra are those that had nothing to join to. It means they have no
# cycling infrastructure. We will give them a value of 0 for cycle_infra
graph_sf$cycle_infra[is.na(graph_sf$cycle_infra)] <- 0
# save it as an RDS
saveRDS(graph_sf, file = paste0("../data/", chosen_city, "/graph_with_flows_default.Rds"))
#clean environment
rm(bicycle, cycle_designated, cycleway, cycleways, graph_sf,
graph_sf_cycle, highway, lanes, maxspeed, msoa_centroids, pts, segregated,
sel_sgbp, streetnet, streetnet2, sel_logical)
library(sf)
graph_sf <- readRDS(paste0("../data/", chosen_city, "/graph_with_flows_default.RDS"))
# column to prioritize by. Change later
#graph_sf$flow_normalized <- graph_sf$flow / graph_sf$d_weighted
######
#GROWING A NETWORK
######
# copy of graph to edit
x <- graph_sf
#get edge_id of edge with highest flow
edge_sel <- x$edge_id[which.max(x$flow)]
# prepare row for adding to new df
x <- x %>% filter(edge_id == edge_sel) %>%
mutate(sequence= 0)
# we don't want to include edges that already have cycling infrastructure in the iterator
# because they won't cost anything
if (x$cycle_infra == 0) {
i <- 1} else {
i <- 0}
while (i < 50){
# remove rows that have already been selected
remaining <- graph_sf %>% filter(!(edge_id %in% x$edge_id))
# identify road segments that neighbour existing selection
neighb_id <- graph_sf$edge_id[which(graph_sf$from_id %in% x$from_id |
graph_sf$from_id %in% x$to_id |
graph_sf$to_id %in% x$from_id |
graph_sf$to_id %in% x$to_id)]
# get neighbouring edges
neighb <- remaining %>% filter(edge_id %in% neighb_id)
# get id of best neighboring edge
edge_sel <- neighb$edge_id[which.max(neighb$flow)]
# get nest neighboring edge as df row
edge_next <- graph_sf %>% filter(edge_id == edge_sel) %>%
mutate(sequence= i)
# append it to the solution
x <- rbind(x, edge_next)
# if chosen edge already has infrastructure, don't count it
if (edge_next$cycle_infra == 0) {
i = i+1}
}
plot(st_geometry(x))
plot(x["sequence"])
#FUNCTIONS
# CHOOSE NUMBER OF SEGMENTS
# inputs
# graph: the graph you want to run the growth function on
# segments: the number of road segments you want to build.
# col_name: the column that you are choosing segments based on, passed inside ""
growth <- function(graph, segments, col_name) {
# copy of graph to edit
x <- graph
#get edge_id of edge with highest flow
edge_sel <- x$edge_id[which.max(x[[col_name]])]
# prepare row for adding to new df
x <- x %>% filter(edge_id == edge_sel) %>%
mutate(sequence= 0)
# we don't want to include edges that already have cycling infrastructure in the iterator
# because they won't cost anything
if (x$cycle_infra == 0) {
i <- 1} else {
i <- 0}
while (i < segments){
# remove rows that have already been selected
remaining <- graph %>% filter(!(edge_id %in% x$edge_id))
# identify road segments that neighbour existing selection
neighb_id <- graph$edge_id[which(graph$from_id %in% x$from_id |
graph$from_id %in% x$to_id |
graph$to_id %in% x$from_id |
graph$to_id %in% x$to_id)]
# get neighbouring edges
neighb <- remaining %>% filter(edge_id %in% neighb_id)
# get id of best neighboring edge
edge_sel <- neighb$edge_id[which.max(neighb[[col_name]])]
# get nest neighboring edge as df row
edge_next <- graph %>% filter(edge_id == edge_sel) %>%
mutate(sequence= i)
# append it to the solution
x <- rbind(x, edge_next)
# Only count selected edges that have no cycling infrastructure
if (edge_next$cycle_infra == 0) {
i = i+1}
}
return(x)
}
# check it
test <- growth(graph_sf, 75, "flow")
plot(st_geometry(test))
plot(st_geometry(graph_sf), col = 'lightgrey')
plot(test["sequence"], add = TRUE)
# CHOOSE LENGTH OF INVESTMENT (KM)
# inputs
# graph: the graph you want to run the growth function on
# km: investment threshold in km
# col_name: the column that you are choosing segments based on, passed inside ""
growth2 <- function(graph, km, col_name) {
# copy of graph to edit
x <- graph
#get edge_id of edge with highest flow
edge_sel <- x$edge_id[which.max(x[[col_name]])]
# prepare row for adding to new df
x <- x %>% filter(edge_id == edge_sel) %>%
mutate(sequence= 0)
# i keeps track of which iteration a chosen edge was added in
i <- 1
if (x$cycle_infra == 0) {
j <- x$d} else {
j <- 0}
#while length of chosen segments is less than specified length
while (j/1000 < km){
# remove rows that have already been selected
remaining <- graph %>% filter(!(edge_id %in% x$edge_id))
# identify road segments that neighbour existing selection
neighb_id <- graph$edge_id[which(graph$from_id %in% x$from_id |
graph$from_id %in% x$to_id |
graph$to_id %in% x$from_id |
graph$to_id %in% x$to_id)]
# get neighbouring edges
neighb <- remaining %>% filter(edge_id %in% neighb_id)
# get id of best neighboring edge
edge_sel <- neighb$edge_id[which.max(neighb[[col_name]])]
# get nest neighboring edge as df row
edge_next <- graph %>% filter(edge_id == edge_sel) %>%
mutate(sequence= i)
# append it to the solution
x <- rbind(x, edge_next)
i = i+1
# Only count length of selected edges that have no cycling infrastructure.
# if condition is not met, j will not be changed in this iteration
if (edge_next$cycle_infra == 0) {
j = j + edge_next$d}
}
return(x)
}
# check it
test2 <- growth2(graph_sf, 75, "flow")
plot(st_geometry(test2))
plot(test2["sequence"])
plot(st_geometry(graph_sf), col = 'lightgrey')
plot(test2["sequence"], add = TRUE)
# check that length argument was respected. length_total should be equal to passed length for
# cycle_infra == 0
test2 %>% st_drop_geometry %>% group_by(cycle_infra) %>%
summarize(length_total = sum(d))
knitr::opts_chunk$set(echo = TRUE)
summary(cars)
library(osmdata)
library(sfnetworks)
library(pct)
# get population weighted centroids from pct and change crs (default is northing)
msoa_centroids <- pct::get_centroids_ew() %>% st_transform(4326)
# get population weighted centroids from pct and change crs (default is northing)
msoa_centroids <- pct::get_centroids_ew() %>% st_transform(4326)
View(msoa_centroids)
library(osmdata)
library(sfnetworks)
library(pct)
library(sf)
roads <- opq ("oxford uk") %>%
add_osm_feature(key = "highway") %>%
osmdata_sf()
View(roads)
class(roads)
class(roads$osm_points)
View(roads)
st_as_sf(roads)
roxel <- sfnetworks::roxel
View(roxel)
class(roxel)
lines <- roads$osm_lines
plot(lines)
plot(st_geometry(lines))
# get road data from osm
#bounding box
bb <- getbb ("oxford uk", format_out = "polygon")
plot(bb)
roads <- opq ("oxford uk") %>%
add_osm_feature(key = "highway", value = c("primary", "secondary", "tertiary")) %>%
osmdata_sf() %>%
trim_osmdata(bb)
plot(st_geometry(roads))
roads <- roads$osm_lines
plot(st_geometry(roads))
plot(bb)
plot(st_geometry(roads), add=T)
# download all road data
roads <- opq ("oxford uk") %>%
add_osm_feature(key = "highway") %>%
osmdata_sf() %>%
trim_osmdata(bb) # trim to bounding box
# extract linestring geometry
roads <- roads$osm_lines
object.size(roads)
plot(bb)
plot(st_geometry(roads), add=T)
st_crs(roads)
plot(st_geometry(msoa_centroids))
# get road data from osm
#bounding box
bb <- getbb ("oxford uk", format_out = "sf_polygon")
# download all road data
roads <- opq ("oxford uk") %>%
add_osm_feature(key = "highway") %>%
osmdata_sf() %>%
trim_osmdata(bb) # trim to bounding box
# extract linestring geometry
roads <- roads$osm_lines
plot(bb)
plot(st_geometry(roads), add=T)
st_filter(msoa_centroids, bb)
plot(bb)
plot(st_geometry(roads), add=T, col="grey")
plot(st_geometry(msoa_centroids), add=T, col="grey")
msoa_centroids <- st_filter(msoa_centroids, bb)
plot(st_geometry(msoa_centroids))
roads <- as_sfnetwork(roads)
plot(roads)
msoa_centroids[[1]]
View(msoa_centroids)
msoa_centroids[[3,1]]
msoa_centroids[[3,3]]
# sample points
p1 <- msoa_centroids[[3,3]]
class(p1)
st_geometry(msoa_centroids[[3]])
msoa_centroids[[3]]
msoa_centroids[[,3]]
msoa_centroids[[3,]]
# sample points
p1 <- msoa_centroids %>% slice(1)
View(p1)
# sample points
p1 <- msoa_centroids %>% slice(1) %>% st_geometry()
# sample points
p1 <- msoa_centroids %>% slice(1) %>% st_geometry()
p2 <- msoa_centroids %>% slice(5) %>% st_geometry()
path <- roads %>% activate("edges") %>%
mutate(weight = edge_length()) %>%
convert(to_spatial_shortest_paths, p1, p2)
path <- roads %>%
activate("edges") %>%
mutate(weight = edge_length()) %>%
convert(to_spatial_shortest_paths, p1, p2)
