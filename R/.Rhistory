# writeRaster(uk_elev, '../data/uk_elev.tif')
# # we only need the merged one
# rm(uk_1, uk_2, uk_elev)
# add the elevation data to the vertices
streetnet_sc <- osmdata::osm_elevation(streetnet_sc, elev_file = c('../data/uk_elev.tif'))
# SAVE STREETNET FOR SCRIPT 4. There we will be trying out different weighting profiles
saveRDS(streetnet_sc, file = paste0("../data/",chosen_city,"/unweighted_streetnet.Rds"))
# make graph for routing
graph <- weight_streetnet(streetnet_sc, wt_profile = "bicycle")
# contract graph for faster routing
graph_contracted <- dodgr_contract_graph(graph)
# get distance matrix
dist_mat <- dodgr_dists(graph_contracted, from = msoa_lon_lat, to = msoa_lon_lat) %>% as.data.frame()
# Change column names for pivoting
colnames(dist_mat) <- msoa_centroids$msoa11cd
# column bind to add MSOA IDs to df. If this is done using rownames then then it is added as a column index (cannot pivot)
dist_mat <- cbind(msoa_centroids$msoa11cd, dist_mat) %>% rename(from = `msoa_centroids$msoa11cd`)
# Change to long format to merge with flows
dist_mat <- dist_mat %>%
pivot_longer(-from, names_to = "to", values_to = "dist")
# save to use in calculation of potential demand (next script)
flows_city <- readr::read_csv(paste0("../data/",chosen_city,"/flows_city.csv"))
# flows_london %>% subset(select = -c(city_origin, city_dest)) %>%
#   left_join(dist_mat, by = c("Area of residence" = "from" , "Area of workplace" = "to")) %>%
#   write_csv(path = "../data/flows_dist_for_potential_flow.csv")
flows_slope <- flows_city %>% subset(select = -c(city_origin, city_dest)) %>%
left_join(dist_mat, by = c("Area of residence" = "from" , "Area of workplace" = "to"))
##### ADD SLOPE - START
# add centroids for routing
flows_slope <- flows_slope %>% left_join(msoa_centroids_snapped[,c('msoa11cd' ,'centroid')],
by = c("Area of residence" = "msoa11cd")) %>%
rename(cent_orig = centroid)
flows_slope <- flows_slope %>% left_join(msoa_centroids_snapped[,c('msoa11cd' ,'centroid')],
by = c("Area of workplace" = "msoa11cd")) %>%
rename(cent_dest = centroid)
# coordinates for bb
#pts <- st_coordinates(msoa_centroids_snapped)
# road network for routing (cannot use streetnet_sc from above as stplanr function only takes sf)
net <- dodgr::dodgr_streetnet(pts = pts, expand = 0.1)
# load in elevation data
uk_elev <- raster::raster('../data/uk_elev.tif')
# 1. get geometries
route <- function(df, net){
nrows <- nrow(df)
i = 1:nrows
# # empty geometry column and assign it's crs
df$route = st_sfc(lapply(1:nrows, function(x) st_geometrycollection()))
st_crs(df$route) <- 4326
# get shortest route for each OD pair
df$route[i] <- st_geometry(stplanr::route_dodgr(from = df$cent_orig[i], to = df$cent_dest[i], net = net))
return(df)
}
# 2. get slopes
slope <- function(df, elev){
nrows <- nrow(df)
i = 1:nrows
# get slope of the shortest route between each OD pair. Route obtained from function above
df$slope[i] <- slopes::slope_raster(df$route[i], elev)
return(df)
}
# get routes column then slope column (function 1 then function 2)
flows_slope <- flows_slope %>% route(net = net) %>% slope(elev = uk_elev)
flows_slope %>%
dplyr::select(-c(cent_orig, cent_dest, route)) %>%
write_csv(path = paste0("../data/",chosen_city,"/flows_dist_elev_for_potential_flow.csv"))
##### ADD SLOPE - END
##########
# GETTING SF STRAIGHT LINE DISTANCES TO COMPARE WITH RESULTS
##########
# flows_london <- read_csv("../data/flows_london.csv") %>%
#       subset(select = -c(city_origin, city_dest))
#
# # add geometry of origin
# flows_london <- flows_london %>% left_join(spatial_london[ , c("MSOA11CD", "geometry", "centroid")],
#                                            by = c("Area of residence" = "MSOA11CD")) %>%
#   rename(geom_orig = geometry, cent_orig = centroid)
# # add geometry of destination
# flows_london <- flows_london %>% left_join(spatial_london[ , c("MSOA11CD", "geometry", "centroid")],
#                                            by = c("Area of workplace" = "MSOA11CD")) %>%
#   rename(geom_dest = geometry, cent_dest = centroid)
#
# # get straight line distances - this takes TIMMEEEE
# flows_london <- flows_london %>%
#   mutate(dist =st_distance(cent_orig, cent_dest, by_element = T))
#
#
# # Create dataframe with both straight line distances and dodgr distance
# distances <- flows_london %>%
#   subset(select = -c(geom_orig, geom_dest, cent_orig, cent_dest)) %>%
#   subset(select = c(`Area of residence`, `Area of workplace`, dist)) %>%
#   rename(dist_straight = dist) %>%
#   left_join(dist_mat, by = c("Area of residence" = "from", "Area of workplace" = "to")) %>%
#   rename(dist_dodgr = dist)
#
# # save for reference
# write_csv(distances, path = paste0("../data/",chosen_city, dist_straight_vs_dodgr.csv"))
# remove variables from global environment
rm(city_names, dist_mat, flows_city, flows_slope, graph, graph_contracted,
msoa_centroids, msoa_centroids_snapped, msoa_lon_lat, msoas_city,
net, pts, streetnet_sc, uk_elev)
library(tidyverse)
library(stplanr)
library(pct)
# read in the data
flow <- readr::read_csv(paste0("../data/",chosen_city,"/flows_dist_elev_for_potential_flow.csv"))
# replace NA values with the mean slope
flow$slope[is.na(flow$slope)] <- mean(na.omit(flow$slope))
###############
# OPTION 1: Use a distance decay function from pct package https://itsleeds.github.io/pct/reference/uptake_pct_godutch.html
###############
# create a copy of the df
uptake_pct <- flow
# get % increase in cycling as distance decay
uptake_pct$uptake_dutch = pct::uptake_pct_godutch(distance = uptake_pct$dist, gradient = uptake_pct$slope)
# ggplot(uptake_pct) +
#   geom_point(aes(dist, uptake_dutch)) +
#   labs( x="Commuting Distance (km)", y = "Uptake (%)")
# get potential demand: non-active flow*uptake + active flow
uptake_pct <- uptake_pct %>%
# get current active travel
mutate(active_travel = Bicycle + `On foot`) %>%
# get potential active travel: non-active modes * distance decay parameter
mutate(potential_demand = round((`All categories: Method of travel to work` - active_travel) * uptake_dutch) + active_travel)
# save csv to use in '4_aggregating_flows'
uptake_pct %>%
subset(select = c(`Area of residence`, `Area of workplace`, `potential_demand`)) %>%
write_csv(path = paste0("../data/",chosen_city, "/flows_for_aggregated_routing_opt_1.csv"))
# all number should be above 0. Cycling should not be more than toal trips...
uptake_pct$increase = uptake_pct$`All categories: Method of travel to work` - uptake_pct$potential_demand
# remove
rm(uptake_pct)
###############
###############
# OPTION 2: without distance decay
###############
# function that takes the following arguments
# 1. dataframe to be used
# 2. max_dist: cutoff distance in meters. All OD pairs above this distance are assumed to have 0 potential demand
# 3. public: fraction of public transport flow that should be considered potential cycling demand
# 4. private: fraction of private vehicle flow that should be considered potential cycling demand
# 3 & 4 are 0 if distance between MSOA pair > max_dist
# 3 & 4 are added to current bicycle trips to create a potential demand column
# Walking is not added to potential demand
potential_demand <- function(data, max_dist = 6000, public = 0.2, private = 0.5) {
name <- data %>%
mutate(active = Bicycle + `On foot`) %>%
mutate(sustainable = (`Underground, metro, light rail, tram` + Train + `Bus, minibus or coach`)) %>%
mutate(motor = (`All categories: Method of travel to work` - (sustainable + active))) %>%
mutate(potential_demand = if_else(dist <= max_dist, round(Bicycle + sustainable*public + motor*private), Bicycle))
return(name)
}
# use function to get potential demand
uptake_cutoff <- potential_demand(data=flow)
# save as csv
uptake_cutoff %>%
subset(select = c(`Area of residence`, `Area of workplace`, `potential_demand`)) %>%
write_csv(path = paste0("../data/",chosen_city, "/flows_for_aggregated_routing_opt_2.csv"))
rm(uptake_cutoff)
###############
###############
# OPTION 3: my own distance decay function
###############
uptake_decay <- flow
# What to do with dist= NA
#1. Remove these rows
#uptake_decay1 <- uptake_decay %>% subset(!is.na(dist))
uptake_decay <- uptake_decay %>% filter(!is.na(dist))
# 2.replace NA values by column mean
#uptake_decay$dist[is.na(uptake_decay$dist)] <- max(uptake_decay$dist[!is.na(uptake_decay$dist)])
# get % of cyclists
uptake_decay$perc_cycle <- uptake_decay$Bicycle / uptake_decay$`All categories: Method of travel to work`
# use this df for glm, as intra flows are all assigned distance 0 and so affect the results
uptake_no_intra <- uptake_decay %>% dplyr::filter(`Area of residence` != `Area of workplace`)
# LOGIT
#glm1 <- glm(perc_cycle ~ dist + slope, data = uptake_no_intra, family = "quasibinomial")
#glm1 <- glm(perc_cycle ~ dist + slope, data = uptake_decay, family = "quasibinomial")
# sqrt to get bell shape!  https://itsleeds.github.io/pct/reference/uptake_pct_govtarget.html
# Should I add all_travel as a predictor???
glm1 <- glm(perc_cycle ~ dist + sqrt(dist) + slope, data = uptake_no_intra, family = "quasibinomial")
# add destination zone as proxy for employment/population of MSOA
# glm2 <- glm(perc_cycle ~ dist + sqrt(dist) + slope + `Area of workplace`,
#             data = uptake_no_intra, family = "quasibinomial")
# If coefficient (logit) is positive, the effect of this predictor on cycling is positive and vice versa
#coeff <- coef(glm1) %>% as.data.frame()
summary(glm1)
#summary(glm2)
# predict cycling probability on all OD pairs
uptake_decay$prob_cycle <- predict(glm1, data.frame(dist = uptake_decay$dist, slope = uptake_decay$slope), type = "response")
# uptake_decay$prob_cycle <- predict(glm2, data.frame(dist = uptake_decay$dist, slope = uptake_decay$slope,
#                                                     `Area of workplace` = uptake_decay$`Area of workplace`),
#                                    type = "response")
# get goodness of fit
rsq  <- function(observed,estimated){
r <- cor(observed,estimated)
R2 <- r^2
R2
}
rsq(uptake_decay$perc_cycle,uptake_decay$prob_cycle)
#rsq(uptake_no_intra$perc_cycle, uptake_no_intra$prob_cycle)
## DISTRIBUTE ADDITIONAL FLOWS ##
# what is the current proportion of cyclists
cycle_current <- sum(uptake_decay$Bicycle) / sum(uptake_decay$`All categories: Method of travel to work`)
# Let's assume we want cycling mode share to increase to 20%
cycle_target <- cycle_current + 0.1
# no. of additional cycling trips needed to acheive target
cycle_add <- round((cycle_target * sum(uptake_decay$`All categories: Method of travel to work`)) - sum(uptake_decay$Bicycle))
####### 3a. FOR OPTION 1 - START #######
# this column is the pool out of which some fraction will be converted to cyclists
uptake_decay$non_active <- uptake_decay$`All categories: Method of travel to work` - (uptake_decay$Bicycle + uptake_decay$`On foot`)
# this would be the additional number of cyclists if we did not have a target to calibrate to
# it is basically the probability from the glm * non_active commuters
uptake_decay$cycle_added_unweighted <- uptake_decay$prob_cycle * uptake_decay$non_active
# But we need to adjust these values so that the additional cyclists = cycle_add
# We solve for X (multiply_factor):
# the idea is that cycle_added_unweighted(1)*X + cycle_added_unweighted(2) *X ..... = Additional Cycling Trips (cycle_add)
multiply_factor <- cycle_add / sum(uptake_decay$cycle_added_unweighted)
# Get the additional number of trips for each OD pair using multiplication factor found above
uptake_decay$cycling_increase <- (uptake_decay$cycle_added_unweighted) * multiply_factor
# Add additional trips to current trips to get future demand
uptake_decay$potential_demand <- round(uptake_decay$cycling_increase) + uptake_decay$Bicycle
# lets see if any of the potential demand values are above the total flow
uptake_decay$cycle_fraction = uptake_decay$potential_demand / uptake_decay$`All categories: Method of travel to work`
# Ideally, all values should be between 0 and 1
max(uptake_decay$cycle_fraction)
min(uptake_decay$cycle_fraction)
# mode share of potential_deand column should = cycle_target
sum(uptake_decay$potential_demand) / sum(uptake_decay$`All categories: Method of travel to work`)
# Show how the number of additional cyclists has been distributed
ggplot(uptake_decay) +
geom_smooth(aes(dist, potential_demand), color = 'green') +
geom_smooth(aes(dist, Bicycle), color = "red") +
labs( x="Commuting Distance (m)", y = "No. of Cyclists")
# show the cycling mode share vs distance
ggplot(uptake_decay) +
geom_smooth(aes(dist, perc_cycle), color = 'red') + # old mode share
geom_smooth(aes(dist, cycle_fraction), color = "green") + # new mode share
labs( x="Commuting Distance (m)", y = "Cycling Mode Share (%)")
#save csv for routing
uptake_decay %>%
subset(select = c(`Area of residence`, `Area of workplace`, `potential_demand`)) %>%
write_csv(path = paste0("../data/",chosen_city, "/flows_for_aggregated_routing_opt_3.csv"))
#save csv for plotting desire_lines
uptake_decay %>%
write_csv(path = paste0("../data/",chosen_city, "/flows_for_desire_lines.csv"))
rm(cycle_add, cycle_current, multiply_factor, uptake_decay, uptake_no_intra, glm1,
rsq, potential_demand, flow)
###############################################################################
######### This script plots the data output from _3_potential_demand ##########
###############################################################################
library(tidyverse)
library(sf)
library(tmap)
uptake_decay <- readr::read_csv(paste0("../data/",chosen_city,"/flows_for_desire_lines.csv"))
# turn distance to km
uptake_no_intra <- uptake_decay %>% dplyr::filter(`Area of residence` != `Area of workplace`)
uptake_no_intra$dist <- uptake_no_intra$dist / 1000
######## PLOT 1: DISTANCE VS TOTAL NO OF CYCLISTS #######
# Not informative as Total Commuting Trips are not equal
uptake_no_intra %>% dplyr::filter(dist <= 10) %>%
ggplot(aes(x = dist, y = Bicycle)) +
geom_point(color = "darkgrey") +
geom_smooth(color = "darkred") +
labs(x="Commuting Distance (km)", y = "Number of Trips Being Cycled",
title = "Number of Commuting Trips Cycled - All Trips Under 10km")
#### PLOT 2 : DISTANCE VS PERCENTAGE CYCLING
uptake_no_intra %>% dplyr::filter(dist <= 10) %>%
ggplot(aes(x = dist, y = perc_cycle)) +
geom_point(color = "darkgrey") +
geom_smooth(color = "darkred") +
labs(x="Commuting Distance (km)", y = "Fraction of Trips Being Cycled",
title = "Fraction of Commuting Trips Cycled - All Trips Under 10km")
# change distance from m to km
uptake_decay$dist <- uptake_decay$dist / 1000
# group data by distance. Change 'by' to edit number of groups
uptake_decay$distance_groups <- cut(uptake_decay$dist, breaks = seq(from = 0, to = 50, by = 1))
uptake_decay_grouped <- uptake_decay %>%
group_by(distance_group = as.character(distance_groups)) %>%
summarise(distance_avg_group   = mean(dist),
group_perc_cycle = mean(perc_cycle) *100,
group_prob_cycle = mean(prob_cycle) *100)
# pivot to long format for ggplot with legend/color argument
uptake_distance_long <- uptake_decay_grouped %>% pivot_longer(cols = c(group_perc_cycle, group_prob_cycle))
ggplot(uptake_distance_long, aes(x = distance_avg_group, y = value, color = name)) +
geom_smooth() +
labs(x="Commuting Distance (km)", y = "% of Trips Cycled",
title = "Probabilty of Cycling \nBased on Distance and Slope") +
scale_color_discrete(name = "", labels = c("Actual", "Estimated"))
# change slope to %
uptake_decay$slope <- uptake_decay$slope * 100
# create slope groups
uptake_decay$slope_group <- cut(uptake_decay$slope, breaks = seq(from = 0, to = 10, by = 0.25))
# group data by slope groups. Remove low levels of cycling as they distort percentages
uptake_decay_slope <- uptake_decay %>% filter(Bicycle >= 15) %>%
group_by(slope_group = as.character(slope_group)) %>%
summarise(slope_avg_group   = mean(slope),
group_perc_cycle = mean(perc_cycle) *100,
group_prob_cycle = mean(prob_cycle) *100)
# pivot to long format for ggplot with legend/color argument
uptake_slope_long <- uptake_decay_slope %>% pivot_longer(cols = c(group_perc_cycle, group_prob_cycle))
ggplot(uptake_slope_long, aes(x = slope_avg_group, y = value, color = name)) +
geom_smooth() +
labs(x="Commuting Distance (km)", y = "Number of Trips Being Cycled",
title = "Probabilty of Cycling Based on Distance and Slope") +
labs(x="Gradient %", y = "% Trips Cycled",
title = "Probabilty of Cycling Based on Distance and Slope") +
scale_color_discrete(name = "", labels = c("Actual", "Estimated"))
# add the group averages to the od data for plotting
uptake_decay <- uptake_decay %>% left_join(uptake_decay_grouped,
by = c("distance_groups" = "distance_group"))
# get the cycling % of each OD pair as a fraction of the distance_group average cycling %
uptake_decay$ratio <- uptake_decay$perc_cycle /  (uptake_decay$group_perc_cycle / 100)  # /100 as perc_cycler is fraction not %
### 5.1 - GGPLOT ###
#### CHECK THIS BEFORE yOU WRECK THIS
# remove 0 distance because they haven't been ssigned to groups
uptake_gg <- uptake_decay %>% filter(dist<10, dist!=0)
order <- c('(0,1]', '(1,2]', '(2,3]', '(3,4]', '(4,5]', '(5,6]', '(6,7]', '(7,8]', '(8,9]', '(9,10]')
ggplot(uptake_gg, aes(x = factor(distance_groups, level = order), y = ratio)) +
geom_boxplot(outlier.size  = 0) +
ylim(NA, 5) +
geom_hline(yintercept=1, linetype="dashed",
color = "darkred", size=0.8)
# MSOA CODES
# get the MSOA codes of MSOAs in the chosen city. Data retrieved from _2_distance_and_elevation
city_msoas <- readr::read_csv(paste0("../data/",chosen_city,"/msoa_codes_city.csv"))
# MSOA CENTROIDS
# get population weighted centroids from pct and change crs (default is northing)
city_centroids <- pct::get_centroids_ew() %>% st_transform(4326)
# keep only centroids of chosen city
city_centroids <- city_centroids %>% dplyr::filter(msoa11cd %in% city_msoas$MSOA11CD)
# MSOA BOUNDARIES
#get msoa boundaries for plotting
city_geom <- sf::st_read("../data-raw/MSOA_2011_Boundaries/Middle_Layer_Super_Output_Areas__December_2011__Boundaries.shp") %>%
st_transform(4326)
# filter only MSOAs in the city_msoas df
city_geom <- city_geom %>% dplyr::filter(msoa11cd %in% city_msoas$MSOA11CD)
# get straight line geometry of all OD pairs. Added as a geometry column
uptake_decay <- stplanr::od2line(uptake_decay, city_centroids)
uptake_decay <- lwgeom::st_make_valid(uptake_decay)
# keep only od pairs <10km
uptake_plot <- uptake_decay %>% filter(dist <= 10)
# plot all flows
tm_shape(city_geom) +
tm_borders(col = "grey80",
lwd = 1,
alpha = 0.5) +
tm_shape(uptake_plot) +
tm_lines(title.col = "Ratio",
legend.lwd.show = FALSE,   # remove lineweight legend
#lwd = "perc_cycle",
lwd = 0.7,
#lwd = "ratio",
col = "ratio",
breaks = c(0, 0.2, 0.5, 1, 3, 10),
midpoint = 1,     # the color palette will split at this point
style = "fixed",
#palette = "RdYlGn",
palette = c('#d7191c', '#fdae61', '#ffffbf', '#a6d96a', '#1a9641'),
#style = "pretty",
scale = 2) +
tm_facets(by="distance_groups",
nrow = 2,
free.coords=FALSE,
showNA = FALSE) +
tm_layout(fontfamily = 'Georgia',
main.title = 'Cycling Relative to OD Pairs in Same Distance Group',
main.title.color = 'grey50',
frame = FALSE) -> p
#save
tmap_save(tm = p, filename = paste0("../data/", chosen_city,"/Plots/facet_desire_lines_all.png"),
width=9, height=4)
# keep only underperforming OD pairs
uptake_low <- uptake_plot %>% filter(ratio < 1)
tm_shape(city_geom) +
tm_borders(col = "grey80",
lwd = 1,
alpha = 0.5) +
tm_shape(uptake_low) +
tm_lines(title.col = "Ratio",
legend.lwd.show = FALSE,   # remove lineweight legend
lwd = 0.7,
col = "ratio",
breaks = c(0, 0.2, 0.5, 0.8, 1),
style = "fixed",
palette = "-OrRd",
scale = 2) +
tm_facets(by="distance_groups",
nrow = 2,
free.coords=FALSE,
showNA = FALSE) +
tm_layout(fontfamily = 'Georgia',
main.title = 'OD Pairs with Flows Below Average',
main.title.color = 'grey50',
frame = FALSE) -> p
#save
tmap_save(tm = p, filename = paste0("../data/", chosen_city,"/Plots/facet_desire_lines_below_avg.png"),
width=9, height=4)
# keep only overperforming OD pairs
uptake_high <- uptake_plot %>% filter(ratio >= 1)
tm_shape(city_geom) +
tm_borders(col = "grey80",
lwd = 1,
alpha = 0.5) +
tm_shape(uptake_high) +
tm_lines(title.col = "Ratio",
legend.lwd.show = FALSE,   # remove lineweight legend
lwd = 0.7,
col = "ratio",
breaks = c(1, 2, 5, 8, 10),
style = "fixed",
palette = "GnBu",
scale = 2) +
tm_facets(by="distance_groups",
nrow = 2,
free.coords=FALSE,
showNA = FALSE) +
tm_layout(fontfamily = 'Georgia',
main.title = 'OD Pairs with Flows Above Average',
main.title.color = 'grey50',
frame = FALSE) -> p
#save
tmap_save(tm = p, filename = paste0("../data/", chosen_city,"/Plots/facet_desire_lines_above_avg.png"),
width=9, height=4)
# get data in long format for ggplot
uptake_decay %>% st_drop_geometry() %>%
select(dist, perc_cycle, cycle_fraction) %>%
mutate(perc_cycle = perc_cycle*100,
cycle_fraction = cycle_fraction*100) %>%
pivot_longer(cols = c(perc_cycle, cycle_fraction)) -> p
# plot
ggplot(p, aes(x= dist, y=value, color = name)) +
geom_smooth() +
labs(title = paste0('Distribution of Cycling Increase \nif Mode Share Reaches ', round(cycle_target*100), '%'),
x="Commuting Distance (km)", y = "Cycling Mode Share (%)") +
scale_color_discrete(name = "", labels = c("Potential", "Current"))
#save
ggsave(paste0("../data/", chosen_city,"/Plots/cycling_increase_line.png"), width = 6, height = 6)
rm(p, uptake_decay, uptake_decay_grouped, uptake_decay_slope, uptake_distance_long, uptake_gg,
uptake_high, uptake_low, uptake_no_intra, uptake_plot, uptake_slope_long, cycle_target, order)
rm(city_centroids, city_geom, city_msoas, p, uptake_decay, uptake_decay_grouped,
uptake_decay_slope, uptake_distance_long, uptake_gg, uptake_high, uptake_low,
uptake_no_intra, uptake_plot, uptake_slope_long, cycle_target, order)
graph_sf_default <- readRDS(paste0("../data/", chosen_city,"/graph_with_flows_default.RDS"))
class(graph_sf_default)
View(graph_sf_default)
rm(graph_sf_default)
graph_t <- readRDS(paste0("../data/", chosen_city,"/graph_with_flows_default.RDS"))
graph_t <- graph_t %>% dplyr::select(flow)
View(graph_t)
graph_tt <- as_sfnetwork(graph_t)
?group_biconnected_component
graph_tt %>% activate("nodes") %>%
graph_tt %>% activate("nodes") %>%
mutate(group = group_louvain(weights = flow))
create_notable('graph_tt')%>% activate("nodes") %>%
mutate(group = group_louvain(weights = flow))
create_notable(graph_tt) %>% activate("nodes") %>%
mutate(group = group_louvain(weights = flow))
r
graph_tt %>% activate("nodes")
graph_tt$flow
graph_tt %>% activate('edges') %>% flow
graph_tt %>% activate('edges') %>% graph_tt$flow
graph_tt %>% activate('edges') %>% select(flow)
x <- graph_tt %>% activate('edges') %>% select(flow)
graph_tt %>% activate("nodes") %>%
mutate(group = group_louvain())
View(graph_tt)
weights = graph_t$flow
graph_tt %>% activate("nodes") %>%
mutate(group = group_louvain(weights = weights))
graph_tt <- as_sfnetwork(graph_t, directed = F)
graph_tt %>% activate("nodes") %>%
mutate(group = group_louvain(weights = weights))
graph_tt %>% activate("nodes") %>%
mutate(group = group_louvain(weights = flow))
graph_tt <- graph_tt %>% activate("nodes") %>%
mutate(group = group_louvain(weights = flow))
tm_shape(graph_tt %>% activate("nodes") %>% st_as_sf()) +
tm_dots(
size = 0.2,
col = "group",
as.count = TRUE,
palette = "viridis",
title = ""
)
tm_shape(graph_tt %>% activate("nodes") %>% st_as_sf()) +
tm_dots(
size = 0.2,
col = "group",
palette = "viridis",
title = ""
)
tm_shape(graph_tt %>% activate("nodes") %>% st_as_sf()) +
tm_dots(
size = 0.2,
col = "group",
#palette = "viridis",
title = ""
)
graph_tt <- graph_tt %>% activate("nodes") %>%
mutate(group = group_louvain(weights = flowss))
graph_tt <- graph_tt %>% activate("nodes") %>%
mutate(group = group_louvain(weights = flo))
View(graph_tt)
View(graph_t)
graph_tt <- graph_tt %>% activate("nodes") %>%
mutate(group = group_louvain(weights = flow))
vignette("sf1")
library(sf)
st_proj_info(type = "proj")
sf::st_proj_info(type = "proj")
rgdal::make_EPSG()
