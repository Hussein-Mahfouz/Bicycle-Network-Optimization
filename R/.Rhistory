# uk_elev <- raster::merge(uk_1, uk_2)
# # write to disk for osm_elevation function (need to pass file path...)
# writeRaster(uk_elev, '../data/uk_elev.tif')
# # we only need the merged one
# rm(uk_1, uk_2, uk_elev)
# add the elevation data to the vertices
streetnet_sc <- osmdata::osm_elevation(streetnet_sc, elev_file = c('../data/uk_elev.tif'))
# make graph for routing
graph <- weight_streetnet(streetnet_sc, wt_profile = "bicycle")
# SAVE TO LOAD IN NEXT TIME!
saveRDS(graph, file = "../data/alt_city/city_graph.Rds")
# contract graph for faster routing
graph_contracted <- dodgr_contract_graph(graph)
# get distance matrix
dist_mat <- dodgr_dists(graph_contracted, from = msoa_lon_lat, to = msoa_lon_lat) %>% as.data.frame()
# Change column names for pivoting
colnames(dist_mat) <- msoa_centroids$msoa11cd
# column bind to add MSOA IDs to df. If this is done using rownames then then it is added as a column index (cannot pivot)
dist_mat <- cbind(msoa_centroids$msoa11cd, dist_mat) %>% rename(from = `msoa_centroids$msoa11cd`)
# Change to long format to merge with flows
dist_mat <- dist_mat %>%
pivot_longer(-from, names_to = "to", values_to = "dist")
# save to use in calculation of potential demand (next script)
flows_city <- readr::read_csv("../data/alt_city/flows_city.csv")
# flows_london %>% subset(select = -c(city_origin, city_dest)) %>%
#   left_join(dist_mat, by = c("Area of residence" = "from" , "Area of workplace" = "to")) %>%
#   write_csv(path = "../data/flows_dist_for_potential_flow.csv")
flows_slope <- flows_city %>% subset(select = -c(city_origin, city_dest)) %>%
left_join(dist_mat, by = c("Area of residence" = "from" , "Area of workplace" = "to"))
##### ADD SLOPE - START
# add centroids for routing
flows_slope <- flows_slope %>% left_join(msoa_centroids_snapped[,c('msoa11cd' ,'centroid')],
by = c("Area of residence" = "msoa11cd")) %>%
rename(cent_orig = centroid)
flows_slope <- flows_slope %>% left_join(msoa_centroids_snapped[,c('msoa11cd' ,'centroid')],
by = c("Area of workplace" = "msoa11cd")) %>%
rename(cent_dest = centroid)
# coordinates for bb
#pts <- st_coordinates(msoa_centroids_snapped)
# road network for routing (cannot use streetnet_sc from above as stplanr function only takes sf)
net <- dodgr::dodgr_streetnet(pts = pts, expand = 0.1)
# load in elevation data
uk_elev <- raster::raster('../data/uk_elev.tif')
# 1. get geometries
route <- function(df, net){
nrows <- nrow(df)
i = 1:nrows
# # empty geometry column and assign it's crs
df$route = st_sfc(lapply(1:nrows, function(x) st_geometrycollection()))
st_crs(df$route) <- 4326
# get shortest route for each OD pair
df$route[i] <- st_geometry(stplanr::route_dodgr(from = df$cent_orig[i], to = df$cent_dest[i], net = net))
return(df)
}
# 2. get slopes
slope <- function(df, elev){
nrows <- nrow(df)
i = 1:nrows
# get slope of the shortest route between each OD pair. Route obtained from function above
df$slope[i] <- slopes::slope_raster(df$route[i], elev)
return(df)
}
# get routes column then slope column (function 1 then function 2)
flows_slope <- flows_slope %>% route(net = net) %>% slope(elev = uk_elev)
flows_slope %>%
dplyr::select(-c(cent_orig, cent_dest, route)) %>%
write_csv(path = "../data/alt_city/flows_dist_elev_for_potential_flow.csv")
##### ADD SLOPE - END
##########
# GETTING SF STRAIGHT LINE DISTANCES TO COMPARE WITH RESULTS
##########
# flows_london <- read_csv("../data/flows_london.csv") %>%
#       subset(select = -c(city_origin, city_dest))
#
# # add geometry of origin
# flows_london <- flows_london %>% left_join(spatial_london[ , c("MSOA11CD", "geometry", "centroid")],
#                                            by = c("Area of residence" = "MSOA11CD")) %>%
#   rename(geom_orig = geometry, cent_orig = centroid)
# # add geometry of destination
# flows_london <- flows_london %>% left_join(spatial_london[ , c("MSOA11CD", "geometry", "centroid")],
#                                            by = c("Area of workplace" = "MSOA11CD")) %>%
#   rename(geom_dest = geometry, cent_dest = centroid)
#
# # get straight line distances - this takes TIMMEEEE
# flows_london <- flows_london %>%
#   mutate(dist =st_distance(cent_orig, cent_dest, by_element = T))
#
#
# # Create dataframe with both straight line distances and dodgr distance
# distances <- flows_london %>%
#   subset(select = -c(geom_orig, geom_dest, cent_orig, cent_dest)) %>%
#   subset(select = c(`Area of residence`, `Area of workplace`, dist)) %>%
#   rename(dist_straight = dist) %>%
#   left_join(dist_mat, by = c("Area of residence" = "from", "Area of workplace" = "to")) %>%
#   rename(dist_dodgr = dist)
#
# # save for reference
# write_csv(distances, path = "../data/dist_straight_vs_dodgr.csv")
# remove variables from global environment
rm(city_names, dist_mat, flows_city, flows_slope, graph, graph_contracted,
msoa_centroids, msoa_centroids_snapped, msoa_lon_lat, msoas_city,
net, pts, streetnet_sc, uk_elev)
library(tidyverse)
library(stplanr)
library(pct)
# read in the data
flow <- readr::read_csv("../data/alt_city/flows_dist_elev_for_potential_flow.csv")
# replace NA values with the mean slope
flow$slope[is.na(flow$slope)] <- mean(na.omit(flow$slope))
###############
# OPTION 1: Use a distance decay function from pct package https://itsleeds.github.io/pct/reference/uptake_pct_godutch.html
###############
# create a copy of the df
uptake_pct <- flow
# get % increase in cycling as distance decay
uptake_pct$uptake_dutch = pct::uptake_pct_godutch(distance = uptake_pct$dist, gradient = uptake_pct$slope)
# ggplot(uptake_pct) +
#   geom_point(aes(dist, uptake_dutch)) +
#   labs( x="Commuting Distance (km)", y = "Uptake (%)")
# get potential demand: non-active flow*uptake + active flow
uptake_pct <- uptake_pct %>%
# get current active travel
mutate(active_travel = Bicycle + `On foot`) %>%
# get potential active travel: non-active modes * distance decay parameter
mutate(potential_demand = round((`All categories: Method of travel to work` - active_travel) * uptake_dutch) + active_travel)
# save csv to use in '4_aggregating_flows'
uptake_pct %>%
subset(select = c(`Area of residence`, `Area of workplace`, `potential_demand`)) %>%
write_csv(path = "../data/alt_city/flows_for_aggregated_routing_opt_1.csv")
# all number should be above 0. Cycling should not be more than toal trips...
uptake_pct$increase = uptake_pct$`All categories: Method of travel to work` - uptake_pct$potential_demand
# remove
rm(uptake_pct)
###############
###############
# OPTION 2: without distance decay
###############
# function that takes the following arguments
# 1. dataframe to be used
# 2. max_dist: cutoff distance in meters. All OD pairs above this distance are assumed to have 0 potential demand
# 3. public: fraction of public transport flow that should be considered potential cycling demand
# 4. private: fraction of private vehicle flow that should be considered potential cycling demand
# 3 & 4 are 0 if distance between MSOA pair > max_dist
# 3 & 4 are added to current bicycle trips to create a potential demand column
# Walking is not added to potential demand
potential_demand <- function(data, max_dist = 6000, public = 0.2, private = 0.5) {
name <- data %>%
mutate(active = Bicycle + `On foot`) %>%
mutate(sustainable = (`Underground, metro, light rail, tram` + Train + `Bus, minibus or coach`)) %>%
mutate(motor = (`All categories: Method of travel to work` - (sustainable + active))) %>%
mutate(potential_demand = if_else(dist <= max_dist, round(Bicycle + sustainable*public + motor*private), Bicycle))
return(name)
}
# use function to get potential demand
uptake_cutoff <- potential_demand(data=flow)
# save as csv
uptake_cutoff %>%
subset(select = c(`Area of residence`, `Area of workplace`, `potential_demand`)) %>%
write_csv(path = "../data/alt_city/flows_for_aggregated_routing_opt_2.csv")
rm(uptake_cutoff)
###############
###############
# OPTION 3: my own distance decay function
###############
uptake_decay <- flow
# What to do with dist= NA
#1. Remove these rows
uptake_decay <- uptake_decay %>% subset(!is.na(dist))
# 2.replace NA values by column mean
#uptake_decay$dist[is.na(uptake_decay$dist)] <- max(uptake_decay$dist[!is.na(uptake_decay$dist)])
# get % of cyclists
uptake_decay$perc_cycle <- uptake_decay$Bicycle / uptake_decay$`All categories: Method of travel to work`
# use this df for glm, as intra flows are all assigned distance 0 and so affect the results
uptake_no_intra <- uptake_decay %>% dplyr::filter(`Area of residence` != `Area of workplace`)
# LOGIT
#glm1 <- glm(perc_cycle ~ dist + slope, data = uptake_no_intra, family = "quasibinomial")
#glm1 <- glm(perc_cycle ~ dist + slope, data = uptake_decay, family = "quasibinomial")
# sqrt to get bell shape!  https://itsleeds.github.io/pct/reference/uptake_pct_govtarget.html
glm1 <- glm(perc_cycle ~ dist + sqrt(dist) + slope, data = uptake_no_intra, family = "quasibinomial")
# add destination zone as proxy for employment/population of MSOA
# glm2 <- glm(perc_cycle ~ dist + sqrt(dist) + slope + `Area of workplace`,
#             data = uptake_no_intra, family = "quasibinomial")
# If coefficient (logit) is positive, the effect of this predictor on cycling is positive and vice versa
#coeff <- coef(glm1) %>% as.data.frame()
summary(glm1)
#summary(glm2)
# predict cycling probability on all OD pairs
uptake_decay$prob_cycle <- predict(glm1, data.frame(dist = uptake_decay$dist, slope = uptake_decay$slope), type = "response")
# uptake_decay$prob_cycle <- predict(glm2, data.frame(dist = uptake_decay$dist, slope = uptake_decay$slope,
#                                                     `Area of workplace` = uptake_decay$`Area of workplace`),
#                                    type = "response")
# get goodness of fit
rsq  <- function(observed,estimated){
r <- cor(observed,estimated)
R2 <- r^2
R2
}
rsq(uptake_decay$perc_cycle,uptake_decay$prob_cycle)
#rsq(uptake_no_intra$perc_cycle, uptake_no_intra$prob_cycle)
ggplot(uptake_decay) +
geom_point(aes(perc_cycle, prob_cycle))
# show probabilty of cycling vs distance
ggplot(uptake_decay) +
geom_point(aes(dist, prob_cycle), color = 'green') +
geom_point(aes(dist, perc_cycle), color = "red") +
labs( x="Commuting Distance (km)", y = "Uptake (%)")
## DISTRIBUTE ADDITIONAL FLOWS ##
# what is the current proportion of cyclists
cycle_current <- sum(uptake_decay$Bicycle) / sum(uptake_decay$`All categories: Method of travel to work`)
# Let's assume we want cycling mode share to increase to 20%
cycle_target <- 0.2
# no. of additional cycling trips needed to acheive target
cycle_add <- round((cycle_target * sum(uptake_decay$`All categories: Method of travel to work`)) - sum(uptake_decay$Bicycle))
####### 3a. FOR OPTION 1 - START #######
# this column is the pool out of which some fraction will be converted to cyclists
uptake_decay$non_active <- uptake_decay$`All categories: Method of travel to work` - (uptake_decay$Bicycle + uptake_decay$`On foot`)
# this would be the additional number of cyclists if we did not have a target to calibrate to
# it is basically the probability from the glm * non_active commuters
uptake_decay$cycle_added_unweighted <- uptake_decay$prob_cycle * uptake_decay$non_active
# But we need to adjust these values so that the additional cyclists = cycle_add
# We solve for X (multiply_factor):
# the idea is that cycle_added_unweighted(1)*X + cycle_added_unweighted(2) *X ..... = Additional Cycling Trips (cycle_add)
multiply_factor <- cycle_add / sum(uptake_decay$cycle_added_unweighted)
# Get the additional number of trips for each OD pair using multiplication factor found above
uptake_decay$cycling_increase <- (uptake_decay$cycle_added_unweighted) * multiply_factor
# Add additional trips to current trips to get future demand
uptake_decay$potential_demand <- round(uptake_decay$cycling_increase) + uptake_decay$Bicycle
# lets see if any of the potential demand values are above the total flow
uptake_decay$cycle_fraction = uptake_decay$potential_demand / uptake_decay$`All categories: Method of travel to work`
# Ideally, all values should be between 0 and 1
max(uptake_decay$cycle_fraction)
min(uptake_decay$cycle_fraction)
# mode share of potential_deand column should = cycle_target
sum(uptake_decay$potential_demand) / sum(uptake_decay$`All categories: Method of travel to work`)
# Show how the number of additional cyclists has been distributed
ggplot(uptake_decay) +
geom_smooth(aes(dist, potential_demand), color = 'green') +
geom_smooth(aes(dist, Bicycle), color = "red") +
labs( x="Commuting Distance (m)", y = "No. of Cyclists")
# show the cycling mode share vs distance
ggplot(uptake_decay) +
geom_smooth(aes(dist, perc_cycle), color = 'red') + # old mode share
geom_smooth(aes(dist, cycle_fraction), color = "green") + # new mode share
labs( x="Commuting Distance (m)", y = "Cycling Mode Share (%)")
#save csv
uptake_decay %>%
subset(select = c(`Area of residence`, `Area of workplace`, `potential_demand`)) %>%
write_csv(path = "../data/alt_city/flows_for_aggregated_routing_opt_3.csv")
rm(cycle_add, cycle_current, cycle_target, multiply_factor, uptake_decay, uptake_no_intra, glm1,
rsq, potential_demand)
########
# PLOTTING DISTANCE VS FLOW
########
#plot distance vs flow
# remove intra flows
flow_plot <- flow %>% dplyr::filter(`Area of residence` != `Area of workplace`)
# all motorized trips
flow_plot$motor <- flow_plot$`Underground, metro, light rail, tram` + flow_plot$Train +
flow_plot$`Bus, minibus or coach` + flow_plot$Taxi + flow_plot$`Motorcycle, scooter or moped` +
flow_plot$`Driving a car or van` + flow_plot$`Passenger in a car or van`
# all non_motorized trips
flow_plot$active <- flow_plot$Bicycle + flow_plot$`On foot`
# all trips by public transport or acyive modes
flow_plot$sustainable <- flow_plot$active + flow_plot$`Underground, metro, light rail, tram` +
flow_plot$Train + flow_plot$`Bus, minibus or coach`
# all trips by private vehicles
flow_plot$private <- flow_plot$Taxi + flow_plot$`Motorcycle, scooter or moped` +
flow_plot$`Driving a car or van` + flow_plot$`Passenger in a car or van`
# subset for histograms
flow_plot <- flow_plot %>% dplyr::select(`Area of residence`, `Area of workplace`,
`All categories: Method of travel to work`,
Bicycle, motor, active, sustainable, private, dist)
# repeat each row based on the value in Bicycle (for histogram!)
flow_long_bike <- flow_plot %>% tidyr::uncount(Bicycle) %>%
dplyr::select(`Area of residence`, `Area of workplace`, dist)
ggplot(flow_long_bike, aes(x = dist)) +
geom_histogram(color = "black", alpha = 0.5, binwidth = 250) +
labs(title = "Bicycle Trips", x="Commuting Distance (km)", y = "No. of trips")
###
flow_long_motor <- flow_plot %>% tidyr::uncount(motor) %>%
dplyr::select(`Area of residence`, `Area of workplace`, dist)
ggplot(flow_long_motor, aes(x = dist)) +
geom_histogram(color = "black", alpha = 0.5) +
labs(title = "All Motorized Trips", x="Commuting Distance (km)", y = "No. of trips")
###
flow_long_active <- flow_plot %>% tidyr::uncount(active) %>%
dplyr::select(`Area of residence`, `Area of workplace`, dist)
ggplot(flow_long_active, aes(x = dist)) +
geom_histogram(color = "black", alpha = 0.5) +
labs(title = "Active Trips", x="Commuting Distance (km)", y = "No. of trips")
###
flow_long_sustainable <- flow_plot %>% tidyr::uncount(sustainable) %>%
dplyr::select(`Area of residence`, `Area of workplace`, dist)
ggplot(flow_long_sustainable, aes(x = dist)) +
geom_histogram(color = "black", alpha = 0.5) +
labs(title = "Trips Made by Sustainable Modes",
x="Commuting Distance (km)", y = "No. of trips")
###
flow_long_private <- flow_plot %>% tidyr::uncount(private) %>%
dplyr::select(`Area of residence`, `Area of workplace`, dist)
ggplot(flow_long_private, aes(x = dist)) +
geom_histogram(color = "black", alpha = 0.5) +
labs(title = "Trips Made by Private Vehicles",
x="Commuting Distance (km)", y = "No. of trips")
# to plot different histograms together
histogram<- rbind(flow_long_motor, flow_long_bike, flow_long_sustainable)
ggplot(histogram, aes(x=dist)) +
geom_histogram(data=flow_long_motor, fill = "blue", alpha = 0.9) +
geom_histogram(data=flow_long_sustainable, fill = "red", alpha = 0.5) +
geom_histogram(data= flow_long_bike, fill = "green", alpha = 0.5)
rm(flow, flow_plot, flow_long_active, flow_long_bike, flow_long_motor, flow_long_private, flow_long_sustainable,
histogram)
########
library(tidyverse)
library(sf)
library(dodgr)
# read in MSOA centroids
lon_lat <- st_read('../data/alt_city/msoa_lon_lat.shp')
# flow data: there are 3 files (check script 3 and choose 1)
od_flow <- read_csv('../data/alt_city/flows_for_aggregated_routing_opt_3.csv')
# remove flows where ORIGIN = DESTINATION
od_flow <- od_flow %>% filter(`Area of residence` != `Area of workplace`)
# tranform into distance matrix for routing.
# column_to_rownames added so that 1st column is not the MSOA names. It assigns the MSOA names to the row ID
od_flow_matrix <-
od_flow %>%
pivot_wider(names_from = `Area of workplace`, values_from = potential_demand) %>%
tibble::column_to_rownames(var = "Area of residence") %>%
replace(is.na(.), 0) %>% as.matrix()
# last line gives 0 values to intra flows, as NAs would cause problems
# This doesn't matter in calculations as intra flows aren't aggregated on road segments
# 'from' is the 1st Column - get the MSOA names using rownames and join them with the coordinates in lon_lat
from <- rownames(od_flow_matrix) %>% as.data.frame() %>% left_join(lon_lat, by = c("." = "msoa11cd")) %>%
dplyr::select(lon, lat) %>% as.matrix()
# same as above but 'to is the column names(i.e. index row)
to <- colnames(od_flow_matrix) %>% as.data.frame() %>% left_join(lon_lat, by = c("." = "msoa11cd")) %>%
dplyr::select(lon, lat) %>% as.matrix()
# # subsets for testing (THIS WORKS)
# from2 <- rownames(od_flow_matrix) %>% as.data.frame() %>% left_join(lon_lat, by = c("." = "MSOA11CD")) %>%
#   dplyr::select(lon, lat) %>% slice(1:10) %>% as.matrix()
# to2 <- colnames(od_flow_matrix) %>% as.data.frame() %>% left_join(lon_lat, by = c("." = "MSOA11CD")) %>%
#   dplyr::select(lon, lat) %>% slice(1:10) %>% as.matrix()
#   # select first 10 rows then 1st 10 columns
# od_flow_matrix_2 <- od_flow_matrix %>% as.data.frame() %>% slice(1:10) %>% select(1:10) %>% as.matrix()
# ROUTE
# load in graph save in script 2
graph <- readRDS('../data/alt_city/city_graph.Rds')
######
# THIS GRAPH HAS THE DEFAULT WEIGHTING PROFILES (so Trunk = 0.3). I will change these:
# library(jsonlite)
# dodgr::write_dodgr_wt_profile(file = "x")
# json_data <- jsonlite::fromJSON(txt="x.json")
# json_data$weighting_profiles$name == 'bicycle'
# get specific row to edit
# json_data$weighting_profiles$name == 'bicycle' & json_data$weighting_profiles$way == 'trunk'
# TO DO THIS I SHOULD EITHER:
# Do this in script 2 (Makes the most sense)
# load streetnet here and edit weighting profiles (discard Rds loaded above)
######
# add flows to road segments
graph_flows <- dodgr_flows_aggregate(
graph = graph,
from = from,
to = to,
flows = od_flow_matrix,
contract = TRUE,
quiet = FALSE)
# Turn into undirected graph
graph_undir <- dodgr::merge_directed_flows(graph_flows)
# convert to sf for prioritixing segments.
# Notice that the segments are merged (much less than graph_flows)
graph_sf <- graph_undir %>% dodgr_to_sf()
# save as RDS to load in next script (geojson, shp etc cause problems)
saveRDS(graph_sf, file = "../data/alt_city/graph_with_flows.Rds")
rm(from, graph, graph_flows, graph_sf, graph_undir, lon_lat, od_flow, od_flow_matrix, to)
library(sf)
graph_sf <- readRDS("../data/alt_city/graph_with_flows.RDS")
# column to prioritize by. Change later
graph_sf$flow_normalized <- graph_sf$flow / graph_sf$d_weighted
######
#GROWING A NETWORK
######
# copy of graph to edit
x <- graph_sf
#get edge_id of edge with highest flow
edge_sel <- x$edge_id[which.max(x$flow_normalized)]
# prepare row for adding to new df
x <- x %>% filter(edge_id == edge_sel) %>%
mutate(sequence= 0)
i <- 1
while (i < 50){
# remove rows that have already been selected
remaining <- graph_sf %>% filter(!(edge_id %in% x$edge_id))
# identify road segments that neighbour existing selection
neighb_id <- graph_sf$edge_id[which(graph_sf$from_id %in% x$from_id |
graph_sf$from_id %in% x$to_id |
graph_sf$to_id %in% x$from_id |
graph_sf$to_id %in% x$to_id)]
# get neighbouring edges
neighb <- remaining %>% filter(edge_id %in% neighb_id)
# get id of best neighboring edge
edge_sel <- neighb$edge_id[which.max(neighb$flow_normalized)]
# get nest neighboring edge as df row
edge_next <- graph_sf %>% filter(edge_id == edge_sel) %>%
mutate(sequence= i)
# append it to the solution
x <- rbind(x, edge_next)
i = i+1
}
plot(st_geometry(x))
plot(x["sequence"])
#FUNCTIONS
# CHOOSE NUMBER OF SEGMENTS
# inputs
# graph: the graph you want to run the growth function on
# segments: the number of road segments you want to build.
# col_name: the column that you are choosing segments based on, passed inside ""
growth <- function(graph, segments, col_name) {
# copy of graph to edit
x <- graph
#get edge_id of edge with highest flow
edge_sel <- x$edge_id[which.max(x[[col_name]])]
# prepare row for adding to new df
x <- x %>% filter(edge_id == edge_sel) %>%
mutate(sequence= 0)
i <- 1
while (i < segments){
# remove rows that have already been selected
remaining <- graph %>% filter(!(edge_id %in% x$edge_id))
# identify road segments that neighbour existing selection
neighb_id <- graph$edge_id[which(graph$from_id %in% x$from_id |
graph$from_id %in% x$to_id |
graph$to_id %in% x$from_id |
graph$to_id %in% x$to_id)]
# get neighbouring edges
neighb <- remaining %>% filter(edge_id %in% neighb_id)
# get id of best neighboring edge
edge_sel <- neighb$edge_id[which.max(neighb[[col_name]])]
# get nest neighboring edge as df row
edge_next <- graph %>% filter(edge_id == edge_sel) %>%
mutate(sequence= i)
# append it to the solution
x <- rbind(x, edge_next)
i = i+1
}
return(x)
}
# check it
test <- growth(graph_sf, 75, "flow_normalized")
plot(st_geometry(test))
plot(test["sequence"])
# CHOOSE LENGTH OF INVESTMENT (KM)
# inputs
# graph: the graph you want to run the growth function on
# km: investment threshold in km
# col_name: the column that you are choosing segments based on, passed inside ""
growth2 <- function(graph, km, col_name) {
# copy of graph to edit
x <- graph
#get edge_id of edge with highest flow
edge_sel <- x$edge_id[which.max(x[[col_name]])]
# prepare row for adding to new df
x <- x %>% filter(edge_id == edge_sel) %>%
mutate(sequence= 0)
j <- x$d
i <- 1
while (j/1000 < km){
# remove rows that have already been selected
remaining <- graph %>% filter(!(edge_id %in% x$edge_id))
# identify road segments that neighbour existing selection
neighb_id <- graph$edge_id[which(graph$from_id %in% x$from_id |
graph$from_id %in% x$to_id |
graph$to_id %in% x$from_id |
graph$to_id %in% x$to_id)]
# get neighbouring edges
neighb <- remaining %>% filter(edge_id %in% neighb_id)
# get id of best neighboring edge
edge_sel <- neighb$edge_id[which.max(neighb[[col_name]])]
# get nest neighboring edge as df row
edge_next <- graph %>% filter(edge_id == edge_sel) %>%
mutate(sequence= i)
# append it to the solution
x <- rbind(x, edge_next)
i = i+1
j = j + edge_next$d
}
return(x)
}
# check it
test2 <- growth2(graph_sf, 75, "flow_normalized")
plot(st_geometry(test2))
plot(test2["sequence"])
plot(st_geometry(graph_sf), col = 'lightgrey')
plot(test["sequence"], add = TRUE)
plot(st_geometry(graph_sf), col = 'lightgrey')
plot(test2["sequence"], add = TRUE)
plot(st_geometry(graph_sf), col = 'lightgrey')
plot(st_geometry(test2), add = TRUE)
plot(graph_sf['flow'])
plot(st_geometry(graph_sf), col = 'lightgrey')
plot(test2["sequence"], add = TRUE)
plot(test2["sequence"])
plot(st_geometry(graph_sf), col = 'lightgrey')
plot(test2["sequence"], add = TRUE)
# read in the data
flow <- readr::read_csv("../data/alt_city/flows_dist_elev_for_potential_flow.csv")
# replace NA values with the mean slope
flow$slope[is.na(flow$slope)] <- mean(na.omit(flow$slope))
# create a copy of the df
uptake_pct <- flow
View(flow)
View(graph_sf)
