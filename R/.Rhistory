if (!is.na(sum(check_conn))){
return(x)
print(paste0("There are no more connected edges to add for all communities. The returned object has ", j,
"km out of the specified ", km, "km"))
}
}
} else{
x <- x
j <- j
}
}
i <- i+1
}
return(x)
}
test <- growth_community_2(graph_sf, 50, "flow")
o
test %>% st_drop_geometry %>% group_by(cycle_infra) %>% summarize(length = sum(d))
plot(st_geometry(graph_sf), col = 'lightgrey')
plot(test["Community"], add = TRUE)
plot(test["Community"])
test <- growth_community_2(graph_sf, 500, "flow")
View(growth_community_2)
sum(test$d)
test %>% st_drop_geometry %>% group_by(cycle_infra) %>% summarize(length = sum(d))
cars
foo=function(cars){
message("pay attention to me!")
Sys.sleep(2)
return(cars)
}
foo
x <- foo
x <- foo()
xx <- foo(cars)
rm(x, xx, foo)
###############################################################
growth_community_2 <- function(graph, km, col_name) {
### check if km chosen is a reasonable number (using a predefined function)
check_km_value(graph, km)
# copy of graph to edit
x <- graph
# Group by community and get the edge with the highest flow in each group
x <- x %>% group_by(Community) %>% top_n(1, !! sym(col_name))
# above might return more than one edge per group (edges tied for highest flow), so here we group the
# result by Community and select the longer edge
x <- x %>% group_by(Community) %>% top_n(1, d) %>%
dplyr::mutate(sequen = 0)
####################
# split the graph into a list of dataframes with length = number of communities
split <- graph %>%
group_split(Community)
# check_conn is a vector of NAs with length = no. of communities. It is used to stop the function if
# there are no more connected edges in any of the communities. Otherwise it will go into an infinite loop.
# We replace the a[i] with the community number if (nrow(neighb) = 0) for that community. If all NAs are replaced
# we break out
check_conn <- rep(NA, length(split))
####################
# i keeps track of which iteration a chosen edge was added in
i <- 1
# j counts km added. We don't count segments that already have cycling infrastructure
j <- sum(x$d) - sum(x$cycle_infra * x$d)
#while length of chosen segments is less than the specified length
while (j/1000 < km){
# for each community
for (k in 1:length(split)){
# edges in community k that have already been chosen
chosen    <- split[[k]] %>% filter((edge_id %in% x$edge_id))
# edges in community k that have not been chosen yet
remaining <- split[[k]] %>% filter(!(edge_id %in% x$edge_id))
if (nrow(remaining) > 0){
# all edges that neighbor the edges in the community that have already been chosen
neighb_id <- split[[k]]$edge_id[which(split[[k]]$from_id %in% chosen$from_id |
split[[k]]$from_id %in% chosen$to_id |
split[[k]]$to_id %in% chosen$from_id |
split[[k]]$to_id %in% chosen$to_id)]
# filter out the remaining edges to keep only the ones that neighbor the chosen edges
neighb <- remaining %>% filter(edge_id %in% neighb_id)
# it may be the case that the remaining edges in the community are not connected to the chosen edges
# the edges in each community do not necessarily form one component. If this is the case, then neighb will
# return an empty sf feature, so an if function is added to only continue if neighb is not empty
if (nrow(neighb) > 0){
#get the edge_id of the edge with the highest flow out of the neighb df
edge_sel <- neighb$edge_id[which.max(neighb[[col_name]])]
# get nthe edge from it's edge id, and add a sequen column to show when it was added to the solution
edge_next <- graph %>% filter(edge_id == edge_sel) %>%
mutate(sequen = i)
# append edge to the solution
x <- rbind(x, edge_next)
# Only count length of selected edges that have no cycling infrastructure.
j = j + (edge_next$d - (edge_next$d * edge_next$cycle_infra))
} else{
x <- x
j <- j
# add the community number to the check_conn vector
check_conn[k] <- k
# if check_conn vector becomes populated with all communities, break out of function
if (!is.na(sum(check_conn))){
message(paste0("There are no more connected edges to add for all communities. The returned object has ", j,
"km out of the specified ", km, "km"))
return(x)
}
}
} else{
x <- x
j <- j
}
}
i <- i+1
}
return(x)
}
test <- growth_community_2(graph_sf, 500, "flow")
round(333323/1000)
###############################################################
growth_community_2 <- function(graph, km, col_name) {
### check if km chosen is a reasonable number (using a predefined function)
check_km_value(graph, km)
# copy of graph to edit
x <- graph
# Group by community and get the edge with the highest flow in each group
x <- x %>% group_by(Community) %>% top_n(1, !! sym(col_name))
# above might return more than one edge per group (edges tied for highest flow), so here we group the
# result by Community and select the longer edge
x <- x %>% group_by(Community) %>% top_n(1, d) %>%
dplyr::mutate(sequen = 0)
####################
# split the graph into a list of dataframes with length = number of communities
split <- graph %>%
group_split(Community)
# check_conn is a vector of NAs with length = no. of communities. It is used to stop the function if
# there are no more connected edges in any of the communities. Otherwise it will go into an infinite loop.
# We replace the a[i] with the community number if (nrow(neighb) = 0) for that community. If all NAs are replaced
# we break out
check_conn <- rep(NA, length(split))
####################
# i keeps track of which iteration a chosen edge was added in
i <- 1
# j counts km added. We don't count segments that already have cycling infrastructure
j <- sum(x$d) - sum(x$cycle_infra * x$d)
#while length of chosen segments is less than the specified length
while (j/1000 < km){
# for each community
for (k in 1:length(split)){
# edges in community k that have already been chosen
chosen    <- split[[k]] %>% filter((edge_id %in% x$edge_id))
# edges in community k that have not been chosen yet
remaining <- split[[k]] %>% filter(!(edge_id %in% x$edge_id))
if (nrow(remaining) > 0){
# all edges that neighbor the edges in the community that have already been chosen
neighb_id <- split[[k]]$edge_id[which(split[[k]]$from_id %in% chosen$from_id |
split[[k]]$from_id %in% chosen$to_id |
split[[k]]$to_id %in% chosen$from_id |
split[[k]]$to_id %in% chosen$to_id)]
# filter out the remaining edges to keep only the ones that neighbor the chosen edges
neighb <- remaining %>% filter(edge_id %in% neighb_id)
# it may be the case that the remaining edges in the community are not connected to the chosen edges
# the edges in each community do not necessarily form one component. If this is the case, then neighb will
# return an empty sf feature, so an if function is added to only continue if neighb is not empty
if (nrow(neighb) > 0){
#get the edge_id of the edge with the highest flow out of the neighb df
edge_sel <- neighb$edge_id[which.max(neighb[[col_name]])]
# get nthe edge from it's edge id, and add a sequen column to show when it was added to the solution
edge_next <- graph %>% filter(edge_id == edge_sel) %>%
mutate(sequen = i)
# append edge to the solution
x <- rbind(x, edge_next)
# Only count length of selected edges that have no cycling infrastructure.
j = j + (edge_next$d - (edge_next$d * edge_next$cycle_infra))
} else{
x <- x
j <- j
# add the community number to the check_conn vector
check_conn[k] <- k
# if check_conn vector becomes populated with all communities, break out of function
if (!is.na(sum(check_conn))){
message(paste0("There are no more connected edges to add for all communities. The returned object has ", round(j/1000),
"km out of the specified ", km, "km"))
return(x)
}
}
} else{
x <- x
j <- j
}
}
i <- i+1
}
return(x)
}
test <- growth_community_2(graph_sf, 500, "flow")
solution <- test
cumulative_df <- solution %>%
ungroup %>%   # not sure why it is a grouped df. This only has an effect on the select argument
st_drop_geometry() %>%
dplyr::select(Community, d, flow, cycle_infra, sequen, perc_dist, perc_flow,
perc_person_km, perc_dist_comm, perc_flow_comm, perc_person_km_comm)
rm(a, test)
# let's grow the network based on the flow column
grow_flow <- growth_community_2(graph = graph_sf, km = sum(graph$d) / 1000, col_name = "flow")
# let's grow the network based on the flow column
grow_flow <- growth_community_2(graph = graph_sf, km = sum(graph[[d]]), col_name = "flow")
# let's grow the network based on the flow column
grow_flow <- growth_community_2(graph = graph_sf, km = sum(graph$d), col_name = "flow")
# let's grow the network based on the flow column
grow_flow <- growth_community_2(graph = graph_sf, km = 1000, col_name = "flow")
# let's grow the network based on the flow column
grow_flow <- growth_community_2(graph = graph_sf, km = 503, col_name = "flow")
# let's grow the network based on the flow column
grow_flow <- growth_community_2(graph = graph_sf, km = 502, col_name = "flow")
graph_sf %>% as_sfnetwork() %>% tidygraph::graph_component_count()
graph_sf %>% as_sfnetwork()
graph_sf %>% as_sfnetwork() %>% graph_component_count()
graph_sf %>% as_sfnetwork() %>% activate("edges") %>% graph_component_count()
as_sfnetwork(graph_sf)
graph_component_count(as_sfnetwork(graph_sf))
library(igraph)
igraph::count_components(as_sfnetwork(graph_sf))
x <- graph_sf %>% slice(10)
igraph::count_components(as_sfnetwork(x))
x <- graph_sf %>% slice(50)
igraph::count_components(as_sfnetwork(x))
plot(x)
y
x <- graph_sf %>% filter(cycle_infra ==0)
igraph::count_components(as_sfnetwork(x))
rm(x)
x <- graph_sf %>% filter(cycle_infra ==1)
igraph::count_components(as_sfnetwork(x))
x<- graph_sf
x %>% mutate(p = igraph::count_components(as_sfnetwork(x)))
View(x)
x <- x %>% mutate(p = igraph::count_components(as_sfnetwork(x)))
rm(x)
graph_sf <- readRDS(paste0("../data/", chosen_city, "/graph_with_flows_default_communities.RDS"))
# we weigh the flow on each edge by its distance. We can then get how much of the commuter km are satisfied
graph_sf$person_km <- graph_sf$flow * graph_sf$d
# get percentage contibution of each edge to the network (distance, flow, person_km)
graph_sf <- graph_sf %>%
mutate(perc_dist = (d/sum(d))  *100,      # edge length as % of total network length
perc_flow = (flow/sum(flow))  *100, # flow on edge as % of total
perc_person_km = (person_km/sum(person_km))  *100) %>% # % of person_km satisfied
# get the same % for each community as a % of the community totals
group_by(Community) %>%
mutate(perc_dist_comm = (d/sum(d)) * 100,
perc_flow_comm = (flow/sum(flow))  *100,
perc_person_km_comm = (person_km/sum(person_km))  *100) %>%
ungroup()
# let's grow the network based on the flow column
grow_flow <- growth_community_2(graph = graph_sf, km = 500, col_name = "flow")
# prepare a dataframe for ggplot
grow_flow_c <- grow_flow %>%
ungroup %>%   # not sure why it is a grouped df. This only has an effect on the select argument
st_drop_geometry() %>%
dplyr::select(Community, d, flow, cycle_infra, sequen, perc_dist, perc_flow,
perc_person_km, perc_dist_comm, perc_flow_comm, perc_person_km_comm)
# cumsum is cumulative sum. We see how much of person_km has been satisfied after each iteration
grow_flow_c <- grow_flow_cum %>%
mutate(cum_dist = cumsum(perc_dist),
cum_person_km = cumsum(perc_person_km)) %>%
# groupby so that you can apply cumsum by community
group_by(Community) %>%
mutate(cum_dist_comm = cumsum(perc_dist_comm),
cum_person_km_comm = cumsum(perc_person_km_comm))
ggplot(data=grow_flow_c , aes(x=cum_dist, y=cum_person_km)) +
geom_line()
# prepare a dataframe for ggplot
grow_flow_c <- grow_flow %>%
ungroup %>%   # not sure why it is a grouped df. This only has an effect on the select argument
st_drop_geometry() %>%
dplyr::select(Community, d, flow, cycle_infra, sequen, perc_dist, perc_flow,
perc_person_km, perc_dist_comm, perc_flow_comm, perc_person_km_comm)
# cumsum is cumulative sum. We see how much of person_km has been satisfied after each iteration
grow_flow_c <- grow_flow_c %>%
mutate(cum_dist = cumsum(perc_dist),
cum_person_km = cumsum(perc_person_km)) %>%
# groupby so that you can apply cumsum by community
group_by(Community) %>%
mutate(cum_dist_comm = cumsum(perc_dist_comm),
cum_person_km_comm = cumsum(perc_person_km_comm))
ggplot(data=grow_flow_c , aes(x=cum_dist, y=cum_person_km)) +
geom_line()
ggplot(data=grow_flow_c , aes(x=cum_dist, y=cum_person_km)) +
geom_line() +
ggtitle("Percentage of Total Flow Traversing \nDifferent Highway Types") +
labs(x = "Highway Type", y = "% of Total Flow")
# cumsum is cumulative sum. We see how much of person_km has been satisfied after each iteration
grow_flow_c <- grow_flow_c %>%
mutate(cum_dist = cumsum(d),
cum_dist_perc = cumsum(perc_dist),
cum_person_km_perc = cumsum(perc_person_km)) %>%
# groupby so that you can apply cumsum by community
group_by(Community) %>%
mutate(cum_dist_comm = cumsum(perc_dist_comm),
cum_person_km_comm = cumsum(perc_person_km_comm))
# cumsum is cumulative sum. We see how much of person_km has been satisfied after each iteration
grow_flow_c <- grow_flow_c %>%
mutate(cum_dist = cumsum(d),
cum_dist_perc = cumsum(perc_dist),
cum_person_km_perc = cumsum(perc_person_km)) %>%
# groupby so that you can apply cumsum by community
group_by(Community) %>%
mutate(cum_dist = cumsum(d),
cum_dist_comm = cumsum(perc_dist_comm),
cum_person_km_comm = cumsum(perc_person_km_comm))
ggplot(data=grow_flow_c , aes(x=cum_dist, y=cum_person_km)) +
geom_line() +
ggtitle("Percentage of Person ") +
labs(x = "", y = "% of Total Flow")
ggplot(data=grow_flow_c , aes(x=cum_dist, y=cum_person_km)) +
geom_point() +
ggtitle("Percentage of Person ") +
labs(x = "", y = "% of Total Flow")
ggplot(data=grow_flow_c, aes(x=cum_dist, y=cum_person_km_comm, group=Community, color = Community)) +
geom_line()
View(grow_flow_c)
# prepare a dataframe for ggplot
grow_flow_c <- grow_flow %>%
ungroup %>%   # not sure why it is a grouped df. This only has an effect on the select argument
st_drop_geometry() %>%
dplyr::select(Community, d, flow, cycle_infra, sequen, perc_dist, perc_flow,
perc_person_km, perc_dist_comm, perc_flow_comm, perc_person_km_comm)
# cumsum is cumulative sum. We see how much of person_km has been satisfied after each iteration
grow_flow_c <- grow_flow_c %>%
mutate(cum_dist = cumsum(d),
cum_dist_perc = cumsum(perc_dist),
cum_person_km_perc = cumsum(perc_person_km)) %>%
# groupby so that you can apply cumsum by community
group_by(Community) %>%
mutate(cum_dist = cumsum(d),
cum_dist_comm = cumsum(perc_dist_comm),
cum_person_km_comm = cumsum(perc_person_km_comm))
# cumsum is cumulative sum. We see how much of person_km has been satisfied after each iteration
grow_flow_c <- grow_flow_c %>%
mutate(dist_c = cumsum(d),
dist_perc_c = cumsum(perc_dist),
person_km_perc_c = cumsum(perc_person_km)) %>%
# groupby so that you can apply cumsum by community
group_by(Community) %>%
mutate(dist_c_comm = cumsum(d),
dist_perc_c_comm = cumsum(perc_dist_comm),
person_km_perc_c_comm = cumsum(perc_person_km_comm))
ggplot(data=grow_flow_c , aes(x=dist_c, y=person_km_perc_c)) +
geom_point() +
ggtitle("Percentage of Person ") +
labs(x = "", y = "% of Total Flow")
View(grow_flow)
# prepare a dataframe for ggplot
grow_flow_c <- grow_flow %>%
ungroup %>%   # not sure why it is a grouped df. This only has an effect on the select argument
st_drop_geometry() %>%
dplyr::select(Community, d, flow, cycle_infra, sequen, perc_dist, perc_flow,
perc_person_km, perc_dist_comm, perc_flow_comm, perc_person_km_comm)
# cumsum is cumulative sum. We see how much of person_km has been satisfied after each iteration
grow_flow_c <- grow_flow_c %>%
mutate(dist_c = cumsum(d),
perc_dist_c = cumsum(perc_dist),
perc_person_km_c = cumsum(perc_person_km)) %>%
# groupby so that you can apply cumsum by community
group_by(Community) %>%
mutate(dist_c_comm = cumsum(d),
perc_dist_comm_c = cumsum(perc_dist_comm),
perc_person_km_comm_c = cumsum(perc_person_km_comm))
ggplot(data=grow_flow_c , aes(x=dist_c, y=person_km_perc_c)) +
geom_point() +
ggtitle("Percentage of Person ") +
labs(x = "", y = "% of Total Flow")
ggplot(data=grow_flow_c , aes(x=dist_c, y=perc_person_km_c)) +
geom_point() +
ggtitle("Percentage of Person ") +
labs(x = "", y = "% of Total Flow")
ggplot(data=grow_flow_c , aes(x=dist_c, y=perc_person_km_c)) +
geom_line() +
ggtitle("Percentage of Person ") +
labs(x = "", y = "% of Total Flow")
# prepare a dataframe for ggplot
grow_flow_c <- grow_flow %>%
ungroup %>%   # not sure why it is a grouped df. This only has an effect on the select argument
st_drop_geometry() %>%
dplyr::select(Community, d, flow, cycle_infra, sequen, perc_dist, perc_flow,
perc_person_km, perc_dist_comm, perc_flow_comm, perc_person_km_comm)
# cumsum is cumulative sum. We see how much of person_km has been satisfied after each iteration
grow_flow_c <- grow_flow_c %>%
mutate(dist_c = cumsum(d),
perc_dist_c = cumsum(perc_dist),
perc_person_km_c = cumsum(perc_person_km)) %>%
# groupby so that you can apply cumsum by community
group_by(Community) %>%
mutate(dist_c_comm = cumsum(d/1000),
perc_dist_comm_c = cumsum(perc_dist_comm),
perc_person_km_comm_c = cumsum(perc_person_km_comm))
ggplot(data=grow_flow_c , aes(x=dist_c, y=perc_person_km_c)) +
geom_line() +
ggtitle("Percentage of Person ") +
labs(x = "", y = "% of Total Flow")
# prepare a dataframe for ggplot
grow_flow_c <- grow_flow %>%
ungroup %>%   # not sure why it is a grouped df. This only has an effect on the select argument
st_drop_geometry() %>%
dplyr::select(Community, d, flow, cycle_infra, sequen, perc_dist, perc_flow,
perc_person_km, perc_dist_comm, perc_flow_comm, perc_person_km_comm)
# cumsum is cumulative sum. We see how much of person_km has been satisfied after each iteration
grow_flow_c <- grow_flow_c %>%
mutate(dist_c = cumsum(d/1000),
perc_dist_c = cumsum(perc_dist),
perc_person_km_c = cumsum(perc_person_km)) %>%
# groupby so that you can apply cumsum by community
group_by(Community) %>%
mutate(dist_c_comm = cumsum(d/1000),
perc_dist_comm_c = cumsum(perc_dist_comm),
perc_person_km_comm_c = cumsum(perc_person_km_comm))
ggplot(data=grow_flow_c , aes(x=dist_c, y=perc_person_km_c)) +
geom_line() +
ggtitle("Percentage of Person ") +
labs(x = "", y = "% of Total Flow")
ggplot(data=grow_flow_c , aes(x=dist_c, y=perc_person_km_c)) +
geom_line() +
ggtitle("Segments Prioritized Based On Flow") +
labs(x = "Length of Investment (km)", y = "% of Person km Covered By Cycling Infrastructe")
ggplot(data=grow_flow_c , aes(x=dist_c, y=perc_person_km_c)) +
geom_line() +
ggtitle("Segments Prioritized Based On Flow") +
labs(x = "Length of Investment (km)", y = "% of person km covered By cycling infrastructure")
ggplot(data=grow_flow_c , aes(x=dist_c, y=perc_person_km_c)) +
geom_line() +
ggtitle("Segments Prioritized Based On Flow") +
labs(x = "Length of Investment (km)", y = "% of person km satisfied",
subtitle="Location")
ggplot(data=grow_flow_c , aes(x=dist_c, y=perc_person_km_c)) +
geom_line() +
ggtitle("Network Level ") +
labs(x = "Length of Investment (km)", y = "% of person km satisfied",
subtitle="Segments Prioritized Based On Flow")
ggplot(data=grow_flow_c , aes(x=dist_c, y=perc_person_km_c)) +
geom_line() +
ggtitle("Connected Growth") +
labs(x = "Length of Investment (km)", y = "% of person km satisfied",
subtitle="Segments Prioritized Based On Flow")
ggplot(data=grow_flow_c,
aes(x=cum_dist, y=cum_person_km_comm, group=Community, color = Community)) +
geom_line()
ggplot(data=grow_flow_c,
aes(x=dist_c_comm, y=perc_person_km_comm_c, group=Community, color = Community)) +
geom_line()
ggplot(data=grow_flow_c , aes(x=dist_c, y=perc_person_km_c)) +
geom_line() +
ggtitle("Connected growth with investment distributed equally between communities") +
labs(x = "Length of Investment (km)", y = "% of person km satisfied",
subtitle="Segments Prioritized Based On Flow")
ggplot(data=grow_flow_c,
aes(x=dist_c_comm, y=perc_person_km_comm_c, group=Community, color = Community)) +
geom_line() +
ggtitle("Connected growth (investment distributed equally between communities)") +
labs(x = "Length of Investment (km)", y = "% of person km satisfied",
subtitle="Segments Prioritized Based On Flow")
# network level plot
ggplot(data=grow_flow_c , aes(x=dist_c, y=perc_person_km_c)) +
geom_line() +
ggtitle("Connected growth (investment distributed equally between communities)") +
labs(x = "Length of Investment (km)", y = "% of person km satisfied",
subtitle=expression("Segments Prioritized Based On"~italic(bacteria X)))
# network level plot
ggplot(data=grow_flow_c , aes(x=dist_c, y=perc_person_km_c)) +
geom_line() +
ggtitle("Connected growth (investment distributed equally between communities)") +
labs(x = "Length of Investment (km)", y = "% of person km satisfied",
subtitle=expression("Segments Prioritized Based On"~italic(bacteria X)~))
# network level plot
ggplot(data=grow_flow_c , aes(x=dist_c, y=perc_person_km_c)) +
geom_line() +
ggtitle("Connected growth (investment distributed equally between communities)") +
labs(x = "Length of Investment (km)", y = "% of person km satisfied",
subtitle=expression("Segments Prioritized Based On"~italic(bacteria X)~""))
# network level plot
ggplot(data=grow_flow_c , aes(x=dist_c, y=perc_person_km_c)) +
geom_line() +
ggtitle("Connected growth (investment distributed equally between communities)") +
labs(x = "Length of Investment (km)", y = "% of person km satisfied",
subtitle=expression('Segments Prioritized Based On'~italic(bacteria X)~''))
# network level plot
ggplot(data=grow_flow_c , aes(x=dist_c, y=perc_person_km_c)) +
geom_line() +
ggtitle("Connected growth (investment distributed equally between communities)") +
labs(x = "Length of Investment (km)", y = "% of person km satisfied",
subtitle=expression('Segments Prioritized Based On' italic(bacteria X) ''))
# network level plot
ggplot(data=grow_flow_c , aes(x=dist_c, y=perc_person_km_c)) +
geom_line() +
ggtitle("Connected growth (investment distributed equally between communities)") +
labs(x = "Length of Investment (km)", y = "% of person km satisfied",
subtitle=expression("Segments Prioritized Based On **Flow**"))
# network level plot
ggplot(data=grow_flow_c , aes(x=dist_c, y=perc_person_km_c)) +
geom_line() +
ggtitle("Connected growth (investment distributed equally between communities)") +
labs(x = "Length of Investment (km)", y = "% of person km satisfied",
subtitle=expression("Segments Prioritized Based On **Flow**")) +
theme(plot.title = element_markdown())
# network level plot
ggplot(data=grow_flow_c , aes(x=dist_c, y=perc_person_km_c)) +
geom_line() +
ggtitle("Connected growth (investment distributed equally between communities)") +
labs(x = "Length of Investment (km)", y = "% of person km satisfied",
subtitle=expression("Segments Prioritized Based On **Flow**")) +
theme_minimal() +
theme(plot.title = element_markdown())
ggplot::element_markdown
ggplot2::element_markdown
library(ggtext)
install.packages("ggtext")
install.packages("ggtext")
install.packages("ggtext")
