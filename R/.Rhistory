neighb_id <- graph$edge_id[which(graph$from_id %in% chosen$from_id |
graph$from_id %in% chosen$to_id |
graph$to_id %in% chosen$from_id |
graph$to_id %in% chosen$to_id)]
# get neighbouring edges
neighb <- remaining %>% filter(edge_id %in% neighb_id)
# get id of best neighboring edge
edge_sel <- neighb$edge_id[which.max(neighb[[col_name]])]
# assign a sequence to the selected edge
graph <- within(graph, sequen[edge_id == edge_sel] <- i)
# modify the chosen sf so that it includes the new edge (new edge no longer has sequen == NA)
chosen <- graph %>% filter(!(is.na(sequen)))
# iterate sequence
i = i+1
# Update length of solution. Only count length of chosen edges (and don't count if edge has cycling infrastructure)
j = sum(chosen$d) - sum(chosen$cycle_infra * chosen$d)
}
# keep only edges/rows that have been chosen
graph <- graph %>% filter(!(is.na(sequen)))
return(graph)
}
old <- growth_one_seed(test, 10, "flow")
new <- growth_one_seed_modified(test, 10, "flow")
install.packages("rbenchmark")
library(rbenchmark)
benchmark(
"old" = {
growth_one_seed(test, 10, "flow")
},
"new" = {
growth_one_seed_modified(test, 10, "flow")
},
columns=c('test', 'elapsed'))
sys.time({growth_one_seed(test, 10, "flow")})
system.time({growth_one_seed(test, 10, "flow")})
system.time({growth_one_seed_modified(test, 10, "flow")})
system.time({growth_one_seed(test, 30, "flow")})
system.time({growth_one_seed_modified(test, 30, "flow")})
system.time({growth_one_seed(test, 100, "flow")})
system.time({growth_one_seed_modified(test, 100, "flow")})
system.time({growth_one_seed(test, 200, "flow")})
system.time({growth_one_seed_modified(test, 200, "flow")})
133/95
70/54
old <- growth_one_seed(test, 30, "flow")
new <- growth_one_seed_modified(test, 30, "flow")
old == new
View(new)
View(old)
test <- readRDS(paste0("../data/", chosen_city, "/graph_with_flows_default_communities.RDS"))
edge_sel <- test$edge_id[which.max(test$flow)]
test <- within(test, sequen[edge_id == edge_sel] <- 5)
test <- readRDS(paste0("../data/", chosen_city, "/graph_with_flows_default_communities.RDS"))
test %>% mutate(sequen= NA)
edge_sel <- test$edge_id[which.max(test$flow)]
test <- within(test, sequen[edge_id == edge_sel] <- 5)
View(test)
test <- test %>% mutate(sequen= NA)
edge_sel <- test$edge_id[which.max(test$flow)]
test <- within(test, sequen[edge_id == edge_sel] <- 5)
test[test$edge_id == edge_sel] <- 2
test$edge_id == edge_sel
test[[test$edge_id == edge_sel]]
[[test$edge_id == edge_sel]]
test$sequen[test$edge_id == edge_sel] <- 2
test <- readRDS(paste0("../data/", chosen_city, "/graph_with_flows_default_communities.RDS"))
growth_one_seed_modified <- function(graph, km, col_name) {
### check if km chosen is a reasonable number (using a predefined function)
check_km_value(graph, km)
# add an empty sequence column
graph %>% mutate(sequen= NA)
#get edge_id of edge with highest flow
edge_sel <- graph$edge_id[which.max(graph[[col_name]])]
# assign a sequence ) to the selected edge
graph <- within(graph, sequen[edge_id == edge_sel] <- 0)
# i keeps track of which iteration a chosen edge was added in
i <- 1
# j counts km added. We don't count segments that already have cycling infrastructure
chosen <- graph %>% filter(!(is.na(sequen)))
j <- sum(chosen$d) - sum(chosen$cycle_infra * chosen$d)
#while length of chosen segments is less than specified length
while (j/1000 < km){
# remove rows that have already been selected (i.e. their sequen value is not  NA)
remaining <- graph %>% filter(is.na(sequen))
# identify road segments that neighbour existing selection
neighb_id <- graph$edge_id[which(graph$from_id %in% chosen$from_id |
graph$from_id %in% chosen$to_id |
graph$to_id %in% chosen$from_id |
graph$to_id %in% chosen$to_id)]
# get neighbouring edges
neighb <- remaining %>% filter(edge_id %in% neighb_id)
# get id of best neighboring edge
edge_sel <- neighb$edge_id[which.max(neighb[[col_name]])]
# assign a sequence to the selected edge
graph <- within(graph, sequen[edge_id == edge_sel] <- i)
# modify the chosen sf so that it includes the new edge (new edge no longer has sequen == NA)
chosen <- graph %>% filter(!(is.na(sequen)))
# iterate sequence
i = i+1
# Update length of solution. Only count length of chosen edges (and don't count if edge has cycling infrastructure)
j = sum(chosen$d) - sum(chosen$cycle_infra * chosen$d)
}
# keep only edges/rows that have been chosen
graph <- graph %>% filter(!(is.na(sequen)))
return(graph)
}
new <- growth_one_seed_modified(test, 30, "flow")
growth_one_seed_modified <- function(graph, km, col_name) {
### check if km chosen is a reasonable number (using a predefined function)
check_km_value(graph, km)
# add an empty sequence column
graph <- graph %>% mutate(sequen= NA)
#get edge_id of edge with highest flow
edge_sel <- graph$edge_id[which.max(graph[[col_name]])]
# assign a sequence ) to the selected edge
graph <- within(graph, sequen[edge_id == edge_sel] <- 0)
# i keeps track of which iteration a chosen edge was added in
i <- 1
# j counts km added. We don't count segments that already have cycling infrastructure
chosen <- graph %>% filter(!(is.na(sequen)))
j <- sum(chosen$d) - sum(chosen$cycle_infra * chosen$d)
#while length of chosen segments is less than specified length
while (j/1000 < km){
# remove rows that have already been selected (i.e. their sequen value is not  NA)
remaining <- graph %>% filter(is.na(sequen))
# identify road segments that neighbour existing selection
neighb_id <- graph$edge_id[which(graph$from_id %in% chosen$from_id |
graph$from_id %in% chosen$to_id |
graph$to_id %in% chosen$from_id |
graph$to_id %in% chosen$to_id)]
# get neighbouring edges
neighb <- remaining %>% filter(edge_id %in% neighb_id)
# get id of best neighboring edge
edge_sel <- neighb$edge_id[which.max(neighb[[col_name]])]
# assign a sequence to the selected edge
graph <- within(graph, sequen[edge_id == edge_sel] <- i)
# modify the chosen sf so that it includes the new edge (new edge no longer has sequen == NA)
chosen <- graph %>% filter(!(is.na(sequen)))
# iterate sequence
i = i+1
# Update length of solution. Only count length of chosen edges (and don't count if edge has cycling infrastructure)
j = sum(chosen$d) - sum(chosen$cycle_infra * chosen$d)
}
# keep only edges/rows that have been chosen
graph <- graph %>% filter(!(is.na(sequen)))
return(graph)
}
new <- growth_one_seed_modified(test, 30, "flow")
growth_one_seed_modified <- function(graph, km, col_name) {
### check if km chosen is a reasonable number (using a predefined function)
check_km_value(graph, km)
# add an empty sequence column
graph <- graph %>% mutate(sequen= NA)
#get edge_id of edge with highest flow
edge_sel <- graph$edge_id[which.max(graph[[col_name]])]
# assign a sequence  to the selected edge
#graph <- within(graph, sequen[edge_id == edge_sel] <- 0)
graph$sequen[graph$edge_id == edge_sel] <- 0
# i keeps track of which iteration a chosen edge was added in
i <- 1
# j counts km added. We don't count segments that already have cycling infrastructure
chosen <- graph %>% filter(!(is.na(sequen)))
j <- sum(chosen$d) - sum(chosen$cycle_infra * chosen$d)
#while length of chosen segments is less than specified length
while (j/1000 < km){
# remove rows that have already been selected (i.e. their sequen value is not  NA)
remaining <- graph %>% filter(is.na(sequen))
# identify road segments that neighbour existing selection
neighb_id <- graph$edge_id[which(graph$from_id %in% chosen$from_id |
graph$from_id %in% chosen$to_id |
graph$to_id %in% chosen$from_id |
graph$to_id %in% chosen$to_id)]
# get neighbouring edges
neighb <- remaining %>% filter(edge_id %in% neighb_id)
# get id of best neighboring edge
edge_sel <- neighb$edge_id[which.max(neighb[[col_name]])]
# assign a sequence to the selected edge
#graph <- within(graph, sequen[edge_id == edge_sel] <- i)
graph$sequen[graph$edge_id == edge_sel] <- i
# modify the chosen sf so that it includes the new edge (new edge no longer has sequen == NA)
chosen <- graph %>% filter(!(is.na(sequen)))
# iterate sequence
i = i+1
# Update length of solution. Only count length of chosen edges (and don't count if edge has cycling infrastructure)
j = sum(chosen$d) - sum(chosen$cycle_infra * chosen$d)
}
# keep only edges/rows that have been chosen
graph <- graph %>% filter(!(is.na(sequen)))
return(graph)
}
new2 <- growth_one_seed_modified(test, 30, "flow")
View(new)
View(new2)
rm(new2)
tt <- as_sfnetwork(graph_sf)
View(tt)
tt[[1]]
tt[[3]]
tt[[7]]
tt[[8]]
rm(tt)
x <- as_sfnetwork(graph_sf)
x %>% activate(edges)
x <- x %>% activate(edges)
View(x)
x <- as_sfnetwork(graph_sf)
x <- x %>% activate(edges) %>% st_as_sf()
View(x)
?across
?dplyr::across
x <- graph_sf %>% slice(1:5)
x %>% mutate(sequen = 1,
# calculate no of components in the solution up to this point
no_components = 5,
# to get size largest connected component
gcc_size = 7)
View(x)
View(x)
x %>% mutate_if(edge_id = "a141083", list(sequen = 1,
# calculate no of components in the solution up to this point
no_components = 5,
# to get size largest connected component
gcc_size = 7))
x %>% mutate(sequen        = case_when(edge_id = "a141083" ~ 2),
no_components = case_when(edge_id = "a141083" ~ 6),
no_components = case_when(edge_id = "a141083" ~ 5))
edge_sel <- "a141083"
x %>% mutate(sequen        = case_when(edge_id = edge_sel ~ 2),
no_components = case_when(edge_id = edge_sel ~ 6),
no_components = case_when(edge_id = edge_sel ~ 5))
x %>% mutate(sequen        = case_when(edge_id == edge_sel ~ 2),
no_components = case_when(edge_id == edge_sel ~ 6),
no_components = case_when(edge_id == edge_sel ~ 5))
x <- x %>% mutate(sequen        = case_when(edge_id == edge_sel ~ 2),
no_components = case_when(edge_id == edge_sel ~ 6),
no_components = case_when(edge_id == edge_sel ~ 5))
x <- x %>% mutate(sequen        = case_when(edge_id == edge_sel ~ 2),
no_components = case_when(edge_id == edge_sel ~ 6),
gcc_size = case_when(edge_id == edge_sel ~ 5))
net <- as_sfnetwork(x)
x <- x %>%
mutate(sequen        = case_when(edge_id == edge_sel ~ 2),
no_components = case_when(edge_id == edge_sel ~ igraph::count_components(net)),
gcc_size      = case_when(edge_id == edge_sel ~ components(net)$csize[which.max(components(net)$csize)]))
View(x)
edge_sel <- "a141080"
x <- x %>%
mutate(sequen        = case_when(edge_id == edge_sel ~ 2),
no_components = case_when(edge_id == edge_sel ~ igraph::count_components(net)),
gcc_size      = case_when(edge_id == edge_sel ~ components(net)$csize[which.max(components(net)$csize)]))
test <- readRDS(paste0("../data/", chosen_city, "/graph_with_flows_default_communities.RDS"))
growth_existing_infra_modified <- function(graph, km, col_name) {
### check if km chosen is a reasonable number (using a predefined function)
check_km_value(graph, km)
# add empty columns for sequence, number of compenents in solution, and size of largest connected component
graph <- graph %>% mutate(sequen= NA,
no_components = NA,
gcc_size = NA)
# get all edges with cycling infrastructure - these are the starting point (sequen = 0)
graph$sequen[graph$cycle_infra == 1] <- 0
# we need a network representation to get no. of components and size of gcc using igraph
net <- graph  %>% filter(!(is.na(sequen))) %>% as_sfnetwork()
# calculate no of components and size of largest connected component (for current solution)
graph <- graph %>%
mutate(no_components = igraph::count_components(net),
gcc_size      = components(net)$csize[which.max(components(net)$csize)])
# i keeps track of which iteration a chosen edge was added in
i <- 1
# we keep track of the edges in the solution, so that we can identify the edges that neighbor them
chosen <- graph %>% filter(!(is.na(sequen)))
# j counts km added. We don't count segments that already have cycling infrastructure
j <- sum(chosen$d) - sum(chosen$cycle_infra * chosen$d)
#while length of chosen segments is less than specified length
while (j/1000 < km){
# candidate list for selection: remove rows that have already been selected (i.e. sequen value is not NA)
remaining <- graph %>% filter(is.na(sequen))
# identify road segments that neighbour existing selection
neighb_id <- graph$edge_id[which(graph$from_id %in% chosen$from_id |
graph$from_id %in% chosen$to_id |
graph$to_id %in% chosen$from_id |
graph$to_id %in% chosen$to_id)]
# get neighbouring edges
neighb <- remaining %>% filter(edge_id %in% neighb_id)
# get id of best neighboring edge
edge_sel <- neighb$edge_id[which.max(neighb[[col_name]])]
# assign a sequence to the selected edge
graph <- graph %>%
mutate(sequen = case_when(edge_id == edge_sel ~ i))
# we need a network representation to get no. of components and size of gcc using igraph
net <- graph  %>% filter(!(is.na(sequen))) %>% as_sfnetwork()
# use case_when to only mutate the row that corresponds to the edge_id of the selected edge
graph <- graph %>%
mutate(# calculate no of components in the solution up to this point
no_components = case_when(edge_id == edge_sel ~ igraph::count_components(net)),
# to get size largest connected component
gcc_size      = case_when(edge_id == edge_sel ~ components(net)$csize[which.max(components(net)$csize)]))
# modify the 'chosen' sf so that it includes the new edge (new edge no longer has sequen == NA)
chosen <- graph %>% filter(!(is.na(sequen)))
# iterate sequence
i = i+1
# Update length of solution. Only count length of chosen edges (and don't count if edge has cycling infrastructure)
j = sum(chosen$d) - sum(chosen$cycle_infra * chosen$d)
}
# keep only edges/rows that have been chosen
graph <- graph %>% filter(!(is.na(sequen)))
return(graph)
}
old <- growth_existing_infra(test, 10, "flow")
new <- growth_existing_infra_modified(test, 10, "flow")
rm(edge_sel)
new <- growth_existing_infra_modified(test, 2, "flow")
i <- 5
x <- test %>% slice(1:5)
View(x)
edge_sel <- "a141080"
x  <- x %>%
mutate(sequen = case_when(edge_id == edge_sel ~ i))
View(x)
x2 <- x %>% filter(!(is.na(sequen)))
View(x2)
rm(net, x, x2)
rm(i)
i <- 5
x <- test %>% slice(1:5)
net <- x %>% as_sfnetwork()
edge_sel <- "a141080"
x  <- x %>%
mutate(sequen = case_when(edge_id == edge_sel ~ i))
x2 <- x %>% filter(!(is.na(sequen))) %>% as_sfnetwork()
View(x2)
View(x2)
i <- 5
x <- test %>% slice(1:5)
net <- x %>% as_sfnetwork()
edge_sel <- "a141080"
x  <- x %>%
mutate(sequen = case_when(edge_id == edge_sel ~ i))
x  <- x %>%
mutate(sequen = case_when(edge_id == "a141080" | "a141081" | "a141082" ~ i))
i <- 5
x <- test %>% slice(1:5)
net <- x %>% as_sfnetwork()
edge_sel <- "a141080"
x  <- x %>%
mutate(sequen = case_when(edge_id == edge_sel ~ i))
x$sequen <- 7
x2 <- x %>% filter(!(is.na(sequen))) %>% as_sfnetwork()
View(x2)
growth_existing_infra_modified <- function(graph, km, col_name) {
### check if km chosen is a reasonable number (using a predefined function)
check_km_value(graph, km)
# add empty columns for sequence, number of compenents in solution, and size of largest connected component
graph <- graph %>% mutate(sequen= NA,
no_components = NA,
gcc_size = NA)
# get all edges with cycling infrastructure - these are the starting point (sequen = 0)
graph$sequen[graph$cycle_infra == 1] <- 0
# we need a network representation to get no. of components and size of gcc using igraph
net <- graph  %>% filter(!(is.na(sequen))) %>% as_sfnetwork()
# calculate no of components and size of largest connected component (for current solution)
# use case_when to only mutate the rows in the initial selection (those with cycling infrastructure)
graph <- graph %>%
mutate(no_components = case_when(cycle_infra == 1 ~ igraph::count_components(net)),
gcc_size      = case_when(cycle_infra == 1 ~ components(net)$csize[which.max(components(net)$csize)]))
# i keeps track of which iteration a chosen edge was added in
i <- 1
# we keep track of the edges in the solution, so that we can identify the edges that neighbor them
chosen <- graph %>% filter(!(is.na(sequen)))
# j counts km added. We don't count segments that already have cycling infrastructure
j <- sum(chosen$d) - sum(chosen$cycle_infra * chosen$d)
#while length of chosen segments is less than specified length
while (j/1000 < km){
# candidate list for selection: remove rows that have already been selected (i.e. sequen value is not NA)
remaining <- graph %>% filter(is.na(sequen))
# identify road segments that neighbour existing selection
neighb_id <- graph$edge_id[which(graph$from_id %in% chosen$from_id |
graph$from_id %in% chosen$to_id |
graph$to_id %in% chosen$from_id |
graph$to_id %in% chosen$to_id)]
# get neighbouring edges
neighb <- remaining %>% filter(edge_id %in% neighb_id)
# get id of best neighboring edge
edge_sel <- neighb$edge_id[which.max(neighb[[col_name]])]
# assign a sequence to the selected edge
graph <- graph %>%
mutate(sequen = case_when(edge_id == edge_sel ~ i))
# we need a network representation to get no. of components and size of gcc using igraph
net <- graph  %>% filter(!(is.na(sequen))) %>% as_sfnetwork()
# use case_when to only mutate the row that corresponds to the edge_id of the selected edge
graph <- graph %>%
mutate(# calculate no of components in the solution up to this point
no_components = case_when(edge_id == edge_sel ~ igraph::count_components(net)),
# to get size largest connected component
gcc_size      = case_when(edge_id == edge_sel ~ components(net)$csize[which.max(components(net)$csize)]))
# modify the 'chosen' sf so that it includes the new edge (new edge no longer has sequen == NA)
chosen <- graph %>% filter(!(is.na(sequen)))
# iterate sequence
i = i+1
# Update length of solution. Only count length of chosen edges (and don't count if edge has cycling infrastructure)
j = sum(chosen$d) - sum(chosen$cycle_infra * chosen$d)
}
# keep only edges/rows that have been chosen
graph <- graph %>% filter(!(is.na(sequen)))
return(graph)
}
new <- growth_existing_infra_modified(test, 2, "flow")
i <- 5
x <- test %>% slice(1:5)
net <- x %>% as_sfnetwork()
edge_sel <- "a141080"
edge_sel2 <- "a141081"
x  <- x %>%
mutate(sequen = case_when(edge_id == edge_sel ~ i))
View(x)
x  <- x %>%
mutate(sequen = case_when(edge_id == edge_sel2 ~ i))
edge_sel <- "a141080"
edge_sel2 <- "a141082"
x  <- x %>%
mutate(sequen = case_when(edge_id == edge_sel ~ i))
x  <- x %>%
mutate(sequen = case_when(edge_id == edge_sel2 ~ i))
i <- 5
x <- test %>% slice(1:5)
edge_sel <- "a141080"
edge_sel2 <- "a141082"
x$sequen[x$edge_id == edge_sel2] <- i
x$sequen[x$edge_id == edge_sel] <- i
growth_existing_infra_modified <- function(graph, km, col_name) {
### check if km chosen is a reasonable number (using a predefined function)
check_km_value(graph, km)
# add empty columns for sequence, number of compenents in solution, and size of largest connected component
graph <- graph %>% mutate(sequen= NA,
no_components = NA,
gcc_size = NA)
# get all edges with cycling infrastructure - these are the starting point (sequen = 0)
graph$sequen[graph$cycle_infra == 1] <- 0
# we need a network representation to get no. of components and size of gcc using igraph
net <- graph  %>% filter(!(is.na(sequen))) %>% as_sfnetwork()
# calculate no of components and size of largest connected component (for current solution)
graph$no_components[graph$cycle_infra == 1] <- igraph::count_components(net)
graph$gcc_size[graph$cycle_infra == 1] <- components(net)$csize[which.max(components(net)$csize)]
# i keeps track of which iteration a chosen edge was added in
i <- 1
# we keep track of the edges in the solution, so that we can identify the edges that neighbor them
chosen <- graph %>% filter(!(is.na(sequen)))
# j counts km added. We don't count segments that already have cycling infrastructure
j <- sum(chosen$d) - sum(chosen$cycle_infra * chosen$d)
#while length of chosen segments is less than specified length
while (j/1000 < km){
# candidate list for selection: remove rows that have already been selected (i.e. sequen value is not NA)
remaining <- graph %>% filter(is.na(sequen))
# identify road segments that neighbour existing selection
neighb_id <- graph$edge_id[which(graph$from_id %in% chosen$from_id |
graph$from_id %in% chosen$to_id |
graph$to_id %in% chosen$from_id |
graph$to_id %in% chosen$to_id)]
# get neighbouring edges
neighb <- remaining %>% filter(edge_id %in% neighb_id)
# get id of best neighboring edge
edge_sel <- neighb$edge_id[which.max(neighb[[col_name]])]
# assign a sequence to the selected edge
graph$sequen[graph$edge_id == edge_sel] <- i
# we need a network representation to get no. of components and size of gcc using igraph
net <- graph  %>% filter(!(is.na(sequen))) %>% as_sfnetwork()
# get no of components and size of largest connected component at this iteration
graph$no_components[graph$edge_id == edge_sel] <- igraph::count_components(net)
graph$gcc_size[graph$edge_id == edge_sel] <- components(net)$csize[which.max(components(net)$csize)]
# modify the 'chosen' sf so that it includes the new edge (new edge no longer has sequen == NA)
chosen <- graph %>% filter(!(is.na(sequen)))
# iterate sequence
i = i+1
# Update length of solution. Only count length of chosen edges (and don't count if edge has cycling infrastructure)
j = sum(chosen$d) - sum(chosen$cycle_infra * chosen$d)
}
# keep only edges/rows that have been chosen
graph <- graph %>% filter(!(is.na(sequen)))
return(graph)
}
new <- growth_existing_infra_modified(test, 2, "flow")
new <- growth_existing_infra_modified(test, 10, "flow")
View(new)
View(old)
# it is faster
system.time({growth_existing_infra(test, 20, "flow")})
system.time({growth_existing_infra_modified(test, 20, "flow")})
29/24
29.1/24.6
system.time({growth_existing_infra(test, 100, "flow")})
system.time({growth_existing_infra_modified(test, 100, "flow")})
142/135
View(old)
View(new)
x <- graph_sf
x %>% group_by(Community) %>% arrange(desc(flow),desc(d)) %>% head(1)
x %>% group_by(Community) %>% arrange(desc(flow),desc(d), .by_group = TRUE) %>% head(1)
x2 <- x %>% group_by(Community) %>% arrange(desc(flow),desc(d), .by_group = TRUE) %>% head(1)
View(x2)
x2 <- x %>% group_by(Community) %>% arrange(desc(flow),desc(d), .by_group = TRUE) %>% head(4)
x2 <- x %>% group_by(Community) %>% arrange(desc(flow),desc(d), .by_group = TRUE)
View(x2)
x2 <- x %>% group_by(Community) %>% slice_max(flow)
?slice_max
update.packages("dplyr")
x2 <- x %>% group_by(Community) %>% slice_max(flow)
x2 <- x %>% group_by(Community) %>% slice_max(order_by = flow)
install.packages("dplyr")
install.packages("dplyr")
install.packages("dplyr")
detach("package:dplyr", unload=TRUE)
unloadNamespace("dplyr")
install.packages("dplyr")
