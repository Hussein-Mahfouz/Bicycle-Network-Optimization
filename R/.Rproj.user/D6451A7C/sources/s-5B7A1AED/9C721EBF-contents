library(sf)
library(sfnetworks)
library(tidyverse)
library(linkcomm)
library(tidygraph)


graph_t <- readRDS(paste0("../data/", chosen_city,"/graph_with_flows_default.RDS"))
graph_t <- graph_t %>% dplyr::select(flow)


##### linkcomm testing #####

graph_link <- graph_t %>% st_drop_geometry %>% dplyr::select(from_id, to_id, flow)
# community detection
lc <- linkcomm::getLinkCommunities(graph_link, hcmethod = "single")
# get edges (output columns: node1, node2, cluster)
lc_edges <- lc$edges
#lc_nodes <- lc$nodeclusters
# count number of edges in each cluster
edge_clusters <- lc_edges %>% group_by(cluster) %>% 
  summarize(count = n()) %>% arrange(desc(count))
# join cluster colun back onto sf graph
graph_t_link <- graph_t %>% left_join(lc_edges, by = c("from_id" = "node1", "to_id" = "node2"))
# get top_n(n) clusters based on the number of edges assigned to them
top_clusters <- edge_clusters %>% top_n(15) %>% select(cluster) 
# change to integer to pass into dplyr::filter
top_clusters <- as.integer(top_clusters$cluster)
# get all edges in the top_n(n) clusters
edges <- graph_t_link %>% dplyr::filter(cluster %in% top_clusters)

# plot to explore
plot(st_geometry(graph_t), col = "lightgrey")
#plot(st_geometry(edges), add = TRUE)
plot(edges['cluster'], add=TRUE)

#tidygraph
nodes <- st_read(paste0("../data/", chosen_city,"/msoa_lon_lat.shp"))
edges <- read_csv(paste0("../data/", chosen_city,"/flows_for_desire_lines.csv"))
# change names of columns to from and to -> UNNECESSARY IF THEY ARE FIRST TWO COLUMNS
# edges <- edges %>% rename(from = `Area of residence`, to = `Area of workplace`) 


# convert edge dataframe to graph
graph <- as_tbl_graph(edges, directed = FALSE)
# choose an a community detection algorithm and assign MSOAs to groups (weight is the flow)
graph_louvain <- graph %>%  activate(nodes) %>%
      mutate(group = group_louvain(weights = `potential_demand`))
# extract nodes so that you can join group results onto the M
graph_nodes <- graph_louvain %>% activate("nodes") %>% as_tibble()
# join group result to each MSOA
nodes <- nodes %>% dplyr::left_join(graph_nodes, by =  c("msoa11cd" = "name"))

# count number of MSOAs in each group
edge_clusters <- nodes %>% st_drop_geometry() %>%
  group_by(group) %>% 
  summarize(count = n()) %>% arrange(desc(count))

plot(st_geometry(graph_t), col = "lightgrey")
plot(nodes['group'])

# read in msoa geometry
msoas <- st_read(paste0("../data/", chosen_city,"/msoas_geometry.shp"))


graph_t <- readRDS(paste0("../data/", chosen_city,"/graph_with_flows_default.RDS"))
graph_t <- graph_t %>% dplyr::select(flow)

plot(st_geometry(msoas), col = "lightgrey")
plot(st_geometry(graph_t), add = TRUE)




# ASSIGNING ROAD EDGES TO MSOAS. 
# Below function does the following:
 # if road segment does not intersect with any msoa border, snap it to the nearesr msoa centroid
 # if road segment interect (crosses) more than one msoa border, calculate the length of intersection with
 # with all intersecting MSOAs and assign it to the one it intersect with most
 # if road segment falls completely within one msoa, assign it to that msoa

assign_edge_to_polygon = function(x, y, z, column) {
  # x = sf with linestring features (road edges)
  # y = sf with polygon features (msoa borders)
  # z = sf with point features (msoa centroids)
  # this function requires a column in y and z named msoa11cd!!!!
  if (inherits(x, "sf")) n = nrow(x)
  if (inherits(x, "sfc")) n = length(x)
  
  out = do.call(c,
                lapply(seq(n), function(i) {
                  # nrst is a list! It returns the msoa row number/s
                  nrst = st_intersects(st_geometry(x)[i], y)
                  # if intersect returns nothing, this edge is outside of all MSOA geometries
                  # get nearest msoa centroid to edge and assign it to it
                  if ( length (nrst[[1]]) == 0 ){
                    nrst = st_nearest_feature(st_geometry(x)[i], z)
                    msoa_code = as.character(z$msoa11cd[nrst[[1]]])
                  }
                  # if edge intersect with more than 1 msoa (does not fall completely inside 1), then
                  # find the length of intersection with each, and assign it to the one it intersects with more
                  else if ( length (nrst[[1]]) > 1 ){
                    # gets the msoa list position of the biggest intersection (intersection length with the different msoas is compared first)
                    a = which.max(st_length(st_intersection(st_geometry(x)[i], y))) 
                    # [[1]] to get the list element with the intersecting msoas
                    # nrst is assigned to the msoa return from a
                    nrst =  nrst[[1]][a]
                    msoa_code = as.character(y$msoa11cd[nrst[[1]]])
                  } 
                  # if edge falls completely inside 1 msoa, assign it to that msoa
                  else {
                    msoa_code = as.character(y$msoa11cd[nrst[[1]]])
                  }
                  # in all cases above, we get the msoa code by pointing to df$column[row number],
                  # where row number is retrieved from the nrst list through nrst[[1]]....ropey
                  return(msoa_code)
                })
  )
  out = dplyr::as_tibble(out)
  return(out)
}


edge_msoas <- assign_edge_to_polygon(graph_t, msoas, nodes)

graph_t <- dplyr::bind_cols(graph_t, edge_msoas)

plot(st_geometry(msoas))
plot(st_geometry(nodes), col = "grey", add = TRUE)
plot(graph_t['value'], add=TRUE)




# to check which features do not intersect at all with MSOAS #id:423
mapview::mapview(bind, zcol="value") + mapview::mapview(msoas)
