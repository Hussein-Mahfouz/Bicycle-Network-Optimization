library(igraph)
library(sf)
library(sfnetworks)
library(tidyverse)
library(rbenchmark)

test <- readRDS(paste0("../data/", chosen_city, "/graph_with_flows_default_communities.RDS"))

test <- test %>% mutate(sequen= NA)
edge_sel <- test$edge_id[which.max(test$flow)]
# replace sequen value with specific value
test <- within(test, sequen[edge_id == edge_sel] <- 5)
# same as above but this is cleaner
test$sequen[test$edge_id == edge_sel] <- 2


growth_one_seed_modified <- function(graph, km, col_name) {
  
  ### check if km chosen is a reasonable number (using a predefined function)
  check_km_value(graph, km)
  # add an empty sequence column
  graph <- graph %>% mutate(sequen= NA)
  #get edge_id of edge with highest flow
  edge_sel <- graph$edge_id[which.max(graph[[col_name]])]
  # assign a sequence  to the selected edge
  #graph <- within(graph, sequen[edge_id == edge_sel] <- 0)
  graph$sequen[graph$edge_id == edge_sel] <- 0
  # i keeps track of which iteration a chosen edge was added in
  i <- 1
  # j counts km added. We don't count segments that already have cycling infrastructure
  chosen <- graph %>% filter(!(is.na(sequen)))
  j <- sum(chosen$d) - sum(chosen$cycle_infra * chosen$d)
  #while length of chosen segments is less than specified length 
  while (j/1000 < km){
    # remove rows that have already been selected (i.e. their sequen value is not  NA)
    remaining <- graph %>% filter(is.na(sequen))
    # identify road segments that neighbour existing selection
    neighb_id <- graph$edge_id[which(graph$from_id %in% chosen$from_id | 
                                       graph$from_id %in% chosen$to_id |
                                       graph$to_id %in% chosen$from_id | 
                                       graph$to_id %in% chosen$to_id)]
    # get neighbouring edges
    neighb <- remaining %>% filter(edge_id %in% neighb_id)
    # get id of best neighboring edge
    edge_sel <- neighb$edge_id[which.max(neighb[[col_name]])]
    # assign a sequence to the selected edge
    #graph <- within(graph, sequen[edge_id == edge_sel] <- i)
    graph$sequen[graph$edge_id == edge_sel] <- i
    # modify the chosen sf so that it includes the new edge (new edge no longer has sequen == NA)
    chosen <- graph %>% filter(!(is.na(sequen)))
    # iterate sequence
    i = i+1
    # Update length of solution. Only count length of chosen edges (and don't count if edge has cycling infrastructure)
    j = sum(chosen$d) - sum(chosen$cycle_infra * chosen$d)
  }
  # keep only edges/rows that have been chosen
  graph <- graph %>% filter(!(is.na(sequen)))
  return(graph)
}

old <- growth_one_seed(test, 30, "flow")

new <- growth_one_seed_modified(test, 30, "flow")



system.time({growth_one_seed(test, 20, "flow")})
system.time({growth_one_seed_modified(test, 20, "flow")})


